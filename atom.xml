<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://accepted.top</id>
    <title>ori&apos;s blog</title>
    <updated>2020-07-20T09:22:49.888Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://accepted.top"/>
    <link rel="self" href="https://accepted.top/atom.xml"/>
    <logo>https://accepted.top/images/avatar.png</logo>
    <icon>https://accepted.top/favicon.ico</icon>
    <rights>All rights reserved 2020, ori&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[7.8模拟赛题解]]></title>
        <id>https://accepted.top/post/78-mo-ni-sai-ti-jie/</id>
        <link href="https://accepted.top/post/78-mo-ni-sai-ti-jie/">
        </link>
        <updated>2020-07-08T11:49:51.000Z</updated>
        <content type="html"><![CDATA[<p>一场爆0模拟赛的垃圾题解。</p>
<p><a href="https://441135118wz.github.io/accepted/post/78-mo-ni-sai-ti-mu/">题面传送门</a></p>
<h3 id="t1">T1：</h3>
<p>T1没有原题，，题意说的还是很清楚，但是考试的时候没有想到用2分。。</p>
<p>这题是2分答案，就是二分需要的天数，只要想到思路，代码还是很短的。</p>
<p>启示：一般让你求最小的答案都可以往二分这方面去想想。</p>
<p>都弄成中位数还是很好证明的，也很常见。</p>
<p>这里先介绍一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>STL</mtext></mrow><annotation encoding="application/x-tex">\text{STL}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">STL</span></span></span></span></span> : <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>t</mi><mi>h</mi><mi mathvariant="normal">_</mi><mi>e</mi><mi>l</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mo>(</mo><mi>b</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>b</mi><mo>+</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo separator="true">,</mo><mi>b</mi><mo>+</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">nth\_element(b+1,b+mid,b+n+1);</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">;</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>o</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">o(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">o</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>找中位数，还是挺好用的。</p>
<p>分析也很难说（更主要是懒），看代码理解一下就好了</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
ll n,q[500005],b[500005];
inline bool check(ll x){
    ll y=x/n,ans=0,mid=(n+1)&gt;&gt;1ll;
    For(i,1,n) b[i]=q[i]+y;
    For(i,1,x%n) b[i]++;
    nth_element(b+1,b+mid,b+n+1);
    For(i,1,n) ans+=abs(b[mid]-b[i]);
    return ans&lt;=x;
}
int main(){
    freopen(&quot;raft.in&quot;,&quot;r&quot;,stdin);
	freopen(&quot;raft.out&quot;,&quot;w&quot;,stdout);
    ll ans;
    read(n);
    For(i,1,n) read(q[i]);
    ll l=1,r=1e15;
    while(l&lt;=r){
        ll mid=(l+r)&gt;&gt;1ll;
        if(check(mid)) r=mid-1,ans=mid;
        else l=mid+1;
    }
    write(ans);
}
</code></pre>
<h3 id="t2">T2:</h3>
<p>T2这题一眼看感觉不是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>dp</mtext></mrow><annotation encoding="application/x-tex">\text{dp}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">dp</span></span></span></span></span> ，感觉后面的选择会影响前面的。（充分体现了直觉的不准。。）</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span></span></span></span> 思路：</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 表示先手拿 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>−</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i-j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 的区间的最大差值。</p>
<p>每一个区间都可以看成一方先手拿走左边 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 个或右边 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 个（ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 是任意数），再 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>dp</mtext></mrow><annotation encoding="application/x-tex">\text {dp}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">dp</span></span></span></span></span> 剩下的那个区间就好了。</p>
<p>这题应该介于记忆化和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>dp</mtext></mrow><annotation encoding="application/x-tex">\text {dp}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">dp</span></span></span></span></span> 之间的吧。</p>
<p>聪明的读者应该会有一个问题，就是在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>dp</mtext></mrow><annotation encoding="application/x-tex">\text{dp}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">dp</span></span></span></span></span> 的过程中会有先后手的区别。</p>
<p>你可以看成一段区间内的区间的dp值是 当对面为先手的时候的差值，（感性理解一下）</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>−</mo><mi>b</mi><mo>=</mo><mo>−</mo><mo>(</mo><mi>b</mi><mo>−</mo><mi>a</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">a-b=-(b-a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mclose">)</span></span></span></span> ，所以减去就好了。</p>
<p>代码：</p>
<pre><code class="language-cpp">int n;
int q[1005],sum[1005],d[1005][1005];
int dfs(int l,int r){
	if(l&gt;r) return 0;
	if(l==r) return d[l][r]=q[l];
	if(d[l][r]!=-INF) return d[l][r];
	For(i,1,r-l+1){
		d[l][r]=max(d[l][r],sum[l+i-1]-sum[l-1]-dfs(l+i,r));
	}
	For(i,1,r-l+1){
		d[l][r]=max(d[l][r],sum[r]-sum[r-i]-dfs(l,r-i));
	}
	return d[l][r];
}
int main(){
	freopen(&quot;farcry.in&quot;,&quot;r&quot;,stdin);
	freopen(&quot;farcry.out&quot;,&quot;w&quot;,stdout);
	while(1){
		For(i,0,100) q[i]=0,sum[i]=0;
		For(i,0,100)
		For(j,0,100) d[i][j]=-INF;
		read(n);
		if(!n) return 0;
		For(i,1,n) read(q[i]),sum[i]=sum[i-1]+q[i];
		write(dfs(1,n));
		puts(&quot;&quot;);
	}
}
</code></pre>
<h3 id="t3">T3:</h3>
<p>​	垃圾结论题。</p>
<p>​	这题只要知道歌德巴赫猜想就好了。（不会证没关系，反正在1e18的范围内已经证明了，可以当结论用的。）</p>
<ol>
<li>每个大于2的偶数都是两个素数之和。</li>
<li>每个大于5的奇数都是三个素数之和。</li>
</ol>
<p>所以答案肯定是1 2 3中间一个。</p>
<p>就直接上代码了。。</p>
<pre><code class="language-cpp">inline bool check(ll a){
	if(a%2==0) return false;
	for(int i=3;i&lt;=sqrt(a)+1;i+=2)
		if(a%i==0) return false;
	return true;
}
signed main(){
	freopen(&quot;taxes.in&quot;,&quot;r&quot;,stdin);
	freopen(&quot;taxes.out&quot;,&quot;w&quot;,stdout);
	int T;
	ll q,ans=0;
	T=read();
	while(T--){
		q=read();
		if(q==2||check(q))cout&lt;&lt;1&lt;&lt;endl;
		else if(q%2==0||(check(q-2))) cout&lt;&lt;2&lt;&lt;endl;
		else cout&lt;&lt;3&lt;&lt;endl;
	}
	
	return 0;
}
</code></pre>
<h3 id="t4">T4：</h3>
<p>原题：<a href="https://www.luogu.com.cn/problem/CF786B">CF786B</a></p>
<p>目前还不会，留坑。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[KMP算法学习小结]]></title>
        <id>https://accepted.top/post/kmp-suan-fa-xue-xi-xiao-jie/</id>
        <link href="https://accepted.top/post/kmp-suan-fa-xue-xi-xiao-jie/">
        </link>
        <updated>2020-07-07T12:07:36.000Z</updated>
        <content type="html"><![CDATA[<h3 id="前言">前言</h3>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>KMP</mtext></mrow><annotation encoding="application/x-tex">\text {KMP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">KMP</span></span></span></span></span> 是我觉得比较难理解的算法之一。</p>
<p>具体可以去别的博客里去多了解一下，这里具体讲思路。</p>
<p>我看过的大多数博客都写的很学术，很长，既没有能力也没有耐心去看，所以这东西就被认为难学。</p>
<p>其实还是挺简单的吧。</p>
<p>所谓失配指针，就是指向在当前字符的前面的离他最近且和它相等的字符的坐标。</p>
<p>设要求字符串 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>a</mtext></mrow><annotation encoding="application/x-tex">\text a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord text"><span class="mord">a</span></span></span></span></span> 里有多少个子串等于字符串 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>b</mtext></mrow><annotation encoding="application/x-tex">\text {b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord">b</span></span></span></span></span> 。</p>
<h3 id="算法流程">算法流程</h3>
<ol>
<li>
<p>我们先预处理失配指针，具体实现和理解下面会讲。</p>
</li>
<li>
<p>然后用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 个指针 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> ， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 扫 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 字符串， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 扫 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 字符串，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>j</mtext><mo>=</mo><mo>(</mo><mtext> j</mtext></mrow><annotation encoding="application/x-tex">\text j= (\ \text j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8623000000000001em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">j</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mspace"> </span><span class="mord text"><span class="mord">j</span></span></span></span></span> 的失配指针 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>)</mo></mrow><annotation encoding="application/x-tex">)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">)</span></span></span></span> 直到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">j=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的时候或者 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo>[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">b[j+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 等于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">a[i+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> ，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo>+</mo><mo>+</mo></mrow><annotation encoding="application/x-tex">j++</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">+</span></span></span></span> 。</p>
</li>
<li>
<p>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 的长度，就已经匹配了。</p>
</li>
<li>
<p>如果你需要没有重叠的字串， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 归零，不然，就再等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 的失配指针。</p>
</li>
</ol>
<h3 id="失配指针原理">失配指针原理</h3>
<p>用人话说，就是上面那句话：指向在当前字符的前面的离他最近且和它相等的字符的坐标。</p>
<p>再直观一点，画个图（画的有点丑，要怪就怪学校的鼠标不好用吧）</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.luogu.com.cn/upload/image_hosting/ffuzwmr5.png" alt="" loading="lazy"></figure>
<p>理解后，就先来说 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>KMP</mtext></mrow><annotation encoding="application/x-tex">\text {KMP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">KMP</span></span></span></span></span> 匹配的部分吧，上面已经说了具体的步骤，这里给一下代码：</p>
<pre><code class="language-cpp">int kmp(){
    int j=0;
    for(int i=0;i&lt;lenb;++i){
        while(j&gt;0&amp;&amp;b[i+1]!=a[j+1]) j=p[j];
        if(b[i+1]==a[j+1]) j++;//上面和这行对应第二步，这里懒得加注释了。
        
        if(j==lena){
            ans++;//这个随意
            //cout&lt;&lt;i+2-lena&lt;&lt;endl;
            j=p[j];//这里看具体题目，现在是允许有重叠部分的字串，如果不允许j要变成0
        }
        
    }
}
</code></pre>
<p>现在再来说说预处理失配指针的思路。</p>
<p>其实和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>KMP</mtext></mrow><annotation encoding="application/x-tex">\text {KMP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">KMP</span></span></span></span></span> 的代码差不多，是自己匹配自己。</p>
<h3 id="流程">流程</h3>
<ol>
<li>用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 个指针 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> ， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>j</mtext><mo>=</mo><mo>(</mo><mtext> j</mtext></mrow><annotation encoding="application/x-tex">\text j= (\ \text j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8623000000000001em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">j</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mspace"> </span><span class="mord text"><span class="mord">j</span></span></span></span></span> 的失配指针 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>)</mo></mrow><annotation encoding="application/x-tex">)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">)</span></span></span></span> 直到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">j=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的时候或者 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo>[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">b[j+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 等于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo>[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">b[i+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> ，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo>+</mo><mo>+</mo></mrow><annotation encoding="application/x-tex">j++</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">+</span></span></span></span> 。</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">b[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 的失配指针指向的就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 。</li>
</ol>
<h5 id="代码">代码：</h5>
<pre><code class="language-cpp">void pre(){
    p[1]=0;
    int j=0;
    for(int i=1;i&lt;lena;++i){
        while(j&gt;0&amp;&amp;a[j+1]!=a[i+1]) j=p[j];
        if(a[j+1]==a[i+1]) j++;
        p[i+1]=j;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[to do!]]></title>
        <id>https://accepted.top/post/to-do/</id>
        <link href="https://accepted.top/post/to-do/">
        </link>
        <updated>2020-07-05T07:11:11.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>DP</li>
<li>线段树</li>
<li>网络流</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P3147题解]]></title>
        <id>https://accepted.top/post/p3147-ti-jie/</id>
        <link href="https://accepted.top/post/p3147-ti-jie/">
        </link>
        <updated>2020-07-02T12:20:50.000Z</updated>
        <content type="html"><![CDATA[<p>题目传送门：<a href="https://www.luogu.com.cn/problem/P3147">P3147</a></p>
<h3 id="前言">前言</h3>
<p>这题是区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>dp</mtext></mrow><annotation encoding="application/x-tex">\text {dp}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">dp</span></span></span></span></span> <strong>绿</strong>题， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>dp</mtext></mrow><annotation encoding="application/x-tex">\text{dp}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">dp</span></span></span></span></span> 还是有点难想的。</p>
<p>一开始觉得和合并石子差不多，后来看了看<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>≤</mo><mn>262144</mn></mrow><annotation encoding="application/x-tex">N\le 262144</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">6</span><span class="mord">2</span><span class="mord">1</span><span class="mord">4</span><span class="mord">4</span></span></span></span>，就不会了，于是去看了题解。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>表示以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 为左端点合并出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 时的右端点。</p>
<p>一看到这个式子的时候，觉得挺奇怪的。</p>
<p>这个用到了类似于倍增的思想，如果所有数都是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>40</mn></mrow><annotation encoding="application/x-tex">40</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">0</span></span></span></span> 的话，最大合出来的数是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>58</mn></mrow><annotation encoding="application/x-tex">58</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">8</span></span></span></span> 。所以就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>58</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">58n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">8</span><span class="mord mathdefault">n</span></span></span></span> 的复杂度。</p>
<p>妙啊！妙啊！</p>
<h3 id="递推式">递推式</h3>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]=dp[i-1][dp[i-1][j]]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mclose">]</span></span></span></span></p>
<p>解释：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[i-1][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 为左端点合并出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 时的右端点， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[i-1][dp[i-1][j]]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mclose">]</span></span></span></span> 就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 堆 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 合起来，这个原理和合并石子差不多的。</p>
<h3 id="初始化">初始化</h3>
<pre><code class="language-cpp">For(i,1,n) dp[q=read()][i]=i+1;//以i为左端点合并出 q 时的右端点是i+1
</code></pre>
<h3 id="代码">代码</h3>
<pre><code class="language-cpp">int main() {
    read(n);
    For(i,1,n) read(q),f[q][i]=i+1;
    For(i,1,58)
    For(j,1,n){
        if(!f[i][j]) f[i][j]=f[i-1][f[i-1][j]];
        if(f[i][j]) ans=i;
    }
    write(ans);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P1637 三元上升子序列 题解]]></title>
        <id>https://accepted.top/post/p1637-san-yuan-shang-sheng-zi-xu-lie-ti-jie/</id>
        <link href="https://accepted.top/post/p1637-san-yuan-shang-sheng-zi-xu-lie-ti-jie/">
        </link>
        <updated>2020-07-02T02:28:36.000Z</updated>
        <content type="html"><![CDATA[<p>题目传送门：<a href="https://www.luogu.com.cn/problem/P1637">三元上升子序列</a></p>
<p>这道题先需要想到一个结论，就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mo>∗</mo><mo>(</mo><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo><mi mathvariant="normal">左</mi><mi mathvariant="normal">边</mi><mi mathvariant="normal">比</mi><mi mathvariant="normal">他</mi><mi mathvariant="normal">小</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">量</mi><mo>)</mo><mo>∗</mo><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo><mi mathvariant="normal">右</mi><mi mathvariant="normal">边</mi><mi mathvariant="normal">比</mi><mi mathvariant="normal">他</mi><mi mathvariant="normal">大</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">量</mi></mrow><annotation encoding="application/x-tex">ans=\sum_{i=1}^{n}*(a[i]左边比他小的数的数量)*a[i]右边比他大的数的数量</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∗</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mord cjk_fallback">左</span><span class="mord cjk_fallback">边</span><span class="mord cjk_fallback">比</span><span class="mord cjk_fallback">他</span><span class="mord cjk_fallback">小</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">量</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mord cjk_fallback">右</span><span class="mord cjk_fallback">边</span><span class="mord cjk_fallback">比</span><span class="mord cjk_fallback">他</span><span class="mord cjk_fallback">大</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">量</span></span></span></span>。</p>
<p>就可以先离散化再2次树状数组就好了。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
int a[200005],b[200005],ans;
int fuck1[200005],fuck2[200005],n,len;
int Left[200005],Right[200005];//开小数组见祖宗 
inline int lowbit(int x){return x&amp;-x;}
inline int add1(int x){for(int i=x;i&lt;=len;i+=lowbit(i))fuck1[i]++;}
inline int add2(int x){for(int i=x;i&lt;=len;i+=lowbit(i))fuck2[i]++;}
inline int ask1(int x){int sum=0;for(int i=x;i;i-=lowbit(i)){sum+=fuck1[i];} return sum;}
inline int ask2(int x){int sum=0;for(int i=x;i;i-=lowbit(i)){sum+=fuck2[i];} return sum;}
signed main() {
    freopen(&quot;T2.in&quot;,&quot;r&quot;,stdin);
    freopen(&quot;T2.out&quot;,&quot;w&quot;,stdout);
	read(n);
	For(i,1,n)read(a[i]),b[i]=a[i];
	
    sort(b+1,b+n+1);
	len=unique(b+1,b+n+1)-b-1;
	For(i,1,n) a[i]=lower_bound(b+1,b+len+1,a[i])-b;//离散化

	For(i,1,n) add1(a[i]),Left[i]=ask1(a[i]-1);
	for(int i=n;i&gt;=1;--i) add2(a[i]),Right[i]=ask2(len)-ask2(a[i]);
    
	For(i,1,n) ans+=Left[i]*Right[i];
	write(ans);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树状数组求逆序对]]></title>
        <id>https://accepted.top/post/shu-zhuang-shu-zu-qiu-ni-xu-dui/</id>
        <link href="https://accepted.top/post/shu-zhuang-shu-zu-qiu-ni-xu-dui/">
        </link>
        <updated>2020-07-01T13:18:00.000Z</updated>
        <content type="html"><![CDATA[<p>从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 枚举，考虑当前枚举到的位置 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> ，他对总的逆序对的个数的贡献就是他前面的权值大于他的权值的数的个数，所以我们在i的权值的位置修改树状数组，表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 的权值这个数已经出现过了，那么到了后面就可以直接查询从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 的权值的位置的总和。</p>
<pre><code class="language-cpp">void add(int i,int t){
    while(i&lt;=len){//这里的len是元素种类，具体见上一篇博客
        c[i]+=t;
        i+=lowbit(i);
    }
}
int main(){
    int n;
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++){
        int t;
        cin&gt;&gt;t;
        add(t,1);
        ans+=i-sum(t);
    }
    for(int i=1;i&lt;=n;i++){
        cout&lt;&lt;c[i]&lt;&lt;endl;
    }
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[离散化]]></title>
        <id>https://accepted.top/post/chi-san-hua/</id>
        <link href="https://accepted.top/post/chi-san-hua/">
        </link>
        <updated>2020-07-01T12:36:26.000Z</updated>
        <content type="html"><![CDATA[<p>离散化：</p>
<pre><code class="language-cpp">For(i,1,n){
	read(a[i].v);
    a[i].id=i;
}
sort(a+1,a+1+n);按v排序
For(i,1,n) b[a[i].id]=i;
</code></pre>
<pre><code class="language-cpp">For(i,1,n)read(a[i]),b[i]=a[i];
 sort(b+1,b+n+1);
len=unique(b+1,b+n+1)-b-1;
For(i,1,n) a[i]=lower_bound(b+1,b+len+1,a[i])-b;
</code></pre>
<p>这是离散化代码。</p>
<p>我来帮助理解一下：</p>
<table>
<thead>
<tr>
<th>v</th>
<th>1005</th>
<th>12</th>
<th>234</th>
<th>5</th>
<th>3421</th>
<th>11111</th>
<th>42</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>
</tbody>
</table>
<p>排序过后：</p>
<table>
<thead>
<tr>
<th>v</th>
<th>5</th>
<th>12</th>
<th>42</th>
<th>234</th>
<th>1005</th>
<th>3421</th>
<th>11111</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>4</td>
<td>2</td>
<td>7</td>
<td>3</td>
<td>1</td>
<td>5</td>
<td>6</td>
</tr>
</tbody>
</table>
<p>最后赋值进b数组</p>
<table>
<thead>
<tr>
<th>b[1]</th>
<th>b[2]</th>
<th>b[3]</th>
<th>b[4]</th>
<th>b[5]</th>
<th>b[6]</th>
<th>b[7]</th>
</tr>
</thead>
<tbody>
<tr>
<td>5</td>
<td>2</td>
<td>4</td>
<td>1</td>
<td>6</td>
<td>7</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>感性理解一下就很简单了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[STL总结]]></title>
        <id>https://accepted.top/post/stl-zong-jie/</id>
        <link href="https://accepted.top/post/stl-zong-jie/">
        </link>
        <updated>2020-06-30T13:12:40.000Z</updated>
        <content type="html"><![CDATA[<h1 id="迭代器">迭代器</h1>
<p>迭代器是一个变量，相当于容器和操纵容器的算法之间的中介。迭代器可以指向容器中的某个元素，通过迭代器就可以读写它指向的元素。</p>
<h1 id="unique">unique</h1>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>unique</mtext></mrow><annotation encoding="application/x-tex">\text {unique}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8623000000000001em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">unique</span></span></span></span></span> 是STL比较实用的一个函数。用于“去除”容器内相邻的重复的元素（只保留一个）。这里说的去除并不是真正将容器内的重复元素删去，只是把重复的元素移到容器最后，但是依然在容器内。 对于数组而言返回去重后最后一个元素的指针，而其他容器则是返回去重后最后一个元素的迭代器。</p>
<h3 id="用法举例">用法举例</h3>
<p>因为是去除相邻的重复元素，因此通常使用前容器应该要是有序的。</p>
<p>数组:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
int main()
{
  int a[6] = {1,1,4,6,6,7};
  int *p = unique(a,a+6);
  cout &lt;&lt; &amp;a[4] &lt;&lt; endl;
  cout &lt;&lt; p &lt;&lt; endl;
  cout &lt;&lt; p - a &lt;&lt;endl;
  for(int i = 0;i &lt; p-a;i++)
      cout &lt;&lt; a[i] &lt;&lt; endl;
  return 0;
}
</code></pre>
<h1 id="vector">vector</h1>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>vector</mtext></mrow><annotation encoding="application/x-tex">\text {vector}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord text"><span class="mord">vector</span></span></span></span></span>可以看成是什么都可以放进去的线性表。</p>
<p>用法：</p>
<pre><code class="language-cpp">vector&lt;int&gt;v;//vector元素为 int 型  
vector&lt;int&gt;::iterator it;//定义一个迭代器

v.push_back()    //在数组的最后添加一个数据
v.pop_back()     //去掉数组的最后一个数据 v.front() 　　　　//返回第一个元素(栈顶元素)
v.begin()        //得到数组头的指针，用迭代器接受
v.end()          //得到数组的最后一个单元+1的指针，用迭代器接受
v.clear()        //移除容器中所有数据
v.empty()        //判断容器是否为空
v.erase(pos)     //删除pos位置的数据
v.erase(beg,end) //删除[beg,end)区间的数据
v.size()         //回容器中实际数据的个数v.insert(pos,data) //在pos处插入数据
</code></pre>
<h1 id="deque">deque</h1>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>deque</mtext></mrow><annotation encoding="application/x-tex">\text {deque}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">deque</span></span></span></span></span> 是双端队列STL，是一种两端都可以进出元素的结构。</p>
<p>用法：</p>
<pre><code class="language-cpp">deque&lt;int&gt; d;
d.push_front(x);    //双端队列头部增加一个元素X
d.push_back(x);     //双端队列尾部增加一个元素X
d.pop_front();      //双端队列头部弹出一个元素X
d.pop_back();       //双端队列尾部弹出一个元素X
d.clear();          //清空双端队列中元素
d.empty();          //队列中是否有元素
d.size();           //队列中元素个数
d.front();          //队列中头部元素
d.back();           //队列中尾部元素
d.begin();          //指向头部元素
d.end();            //指向尾部元素

</code></pre>
<h1 id="stack">stack</h1>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>stack</mtext></mrow><annotation encoding="application/x-tex">\text {stack}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord">stack</span></span></span></span></span>是栈STL，是一种先进后出的结构。</p>
<p>用法：</p>
<pre><code class="language-cpp">stack&lt;int&gt; s;
s.empty();	//栈中是否有元素
s.size();	//栈中元素个数
s.pop();	//弹出栈顶元素
s.top();	//反回栈顶元素
s.push(x);  //栈中压入x元素
</code></pre>
<h1 id="queue">queue</h1>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>queue</mtext></mrow><annotation encoding="application/x-tex">\text {queue}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">queue</span></span></span></span></span> 是队列STL，是一种先进先出的结构。</p>
<p>用法：</p>
<pre><code class="language-cpp">q.empty()// 如果队列为空返回true，否则返回false
q.size() // 返回队列中元素的个数
q.pop()  //删除队列首元素
q.front()  // 返回队首元素的值 
q.push(X) //在队尾压入新元素X
q.back() //返回队列尾元素的值  
</code></pre>
<h1 id="priority_queue">priority_queue</h1>
<p><span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;_&#039; at position 16: \text {priority_̲queue}'>\text {priority_queue}</span>是优先队列STL，优先队列是队列的一种，不过它可以按照自定义的一种方式（数据的优先级）来对队列中的数据进行动态的排序，每次的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>push</mtext></mrow><annotation encoding="application/x-tex">\text {push}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">push</span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>pop</mtext></mrow><annotation encoding="application/x-tex">\text {pop}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">pop</span></span></span></span></span> 操作，队列都会动态的调整，以达到我们预期的方式来存储。</p>
<p>例如，将元素 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>5 3 2 4 6</mtext></mrow><annotation encoding="application/x-tex">\text {5 3 2 4 6}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord text"><span class="mord">5 3 2 4 6</span></span></span></span></span> 依次 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>push</mtext></mrow><annotation encoding="application/x-tex">\text {push}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">push</span></span></span></span></span> 到优先队列中，规定顺序为从大到小并输出，输出顺序为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>6 5 4 3 2</mtext></mrow><annotation encoding="application/x-tex">\text {6 5 4 3 2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord text"><span class="mord">6 5 4 3 2</span></span></span></span></span></p>
<p>定义</p>
<pre><code class="language-cpp">priority_queue&lt;int&gt; p;//最大值优先，是大顶堆一种简写方式
priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;q1;//最小值优先，小顶堆
priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt;q2;//最大值优先，大顶堆

//其中第一个参数是数据类型，第二个参数为容器类型。第三个参数为比较函数。
</code></pre>
<p>在使用时，我们会有很多时间用到根据结构体的某一个元素进行排序，下面给出定义结构体的优先级比较方式</p>
<pre><code class="language-cpp">struct node
{
    string name;
    int price;
    friend bool operator&lt; (node a, node b)
    {
        return a.price &lt; b.price; // 相当于less,这是大顶堆，反之则是小顶堆，最大值优先
    }
} stu; //定义结构体变量

//这样直接可以：
priority_queue&lt;node &gt; q;
</code></pre>
<p>可以将比较运算符外置，方法如下</p>
<pre><code class="language-cpp">struct node
{
    string name;
    int price;
} stu; //定义结构体变量

struct cmp
{
    bool operator () (node a, node b) // 重载括号
    {
        return node.price &lt; node.price; // 相当于less，大顶堆
    }
};
</code></pre>
<p>3.常用操作：</p>
<pre><code class="language-cpp">q.push(x) //将x加入队列中，即入队操作

q.pop() //出队操作(删除队列首元素)，只是出队，没有返回值

q.top() //返回第一个元素(队首元素)优先队列的队首用top，而普通队列的队首用front

q.size() //返回栈队列中的元素个数

q.empty() //当队列为空时，返回 true
</code></pre>
<p>这里放下 <a href="https://www.luogu.com.cn/problem/P1090#submit">P1090 合并果子</a> 的代码，方便理解使用 <span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;_&#039; at position 16: \text {priority_̲queue}'>\text {priority_queue}</span>：</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q;
int main(){
    int a,b,x,y,ans=0;
    read(a);
	For(i,0,a-1) read(b),q.push(b);
	For(i,1,a-1){
		x=q.top();q.pop();
         y=q.top();q.pop();
		q.push(x+y);ans+=x+y;
	}
	write(ans);
}
</code></pre>
<h1 id="set">set</h1>
<h2 id="介绍">介绍</h2>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>set</mtext></mrow><annotation encoding="application/x-tex">\text {set}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord text"><span class="mord">set</span></span></span></span></span> 是集合<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>STL</mtext></mrow><annotation encoding="application/x-tex">\text {STL}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">STL</span></span></span></span></span> ，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>set</mtext></mrow><annotation encoding="application/x-tex">\text {set}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord text"><span class="mord">set</span></span></span></span></span> 是一个内部自动有序且不含重复元素的容器。</p>
<p><strong>set最主要的作用是自动去重并按升序排序</strong></p>
<h2 id="用法">用法：</h2>
<h3 id="1set的定义">1.set的定义</h3>
<pre><code class="language-cpp">set&lt;typename&gt; name；
//这里的typename可以是任何基本类型
//举例：
set&lt;int&gt; name;
set&lt;double&gt; name;
set&lt;char&gt; name;
set&lt;node&gt; name; //node是结构体的类型
</code></pre>
<h3 id="2-set-容器内元素的访问">2. set 容器内元素的访问</h3>
<pre><code>//（重点）set 只能通过迭代器(iterator)访问
set&lt;typename&gt;::iterator it;
</code></pre>
<p>举例：</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int main() {
    set&lt;int&gt; st;
    st.insert(3);   //insert(x)将x插入set中
    st.insert(5);
    st.insert(2);
    st.insert(3);
    for(set&lt;int&gt;::iterator it = st.begin(); it != st.end(); it++) {
        printf(&quot;%d&quot;, *it);
    }
}
</code></pre>
<h3 id="3set常用函数">3.set常用函数</h3>
<ol>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>insert(x)</mtext></mrow><annotation encoding="application/x-tex">\text {insert(x)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">insert(x)</span></span></span></span></span></li>
</ol>
<pre><code class="language-cpp">insert(x);         //insert(x)可将 x 插入 set 容器中，并自动递增排序和去重，时间复杂度O(logN)
</code></pre>
<ol start="2">
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>find(value)</mtext></mrow><annotation encoding="application/x-tex">\text {find(value)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">find(value)</span></span></span></span></span></li>
</ol>
<pre><code class="language-cpp">find(value);       //find(value)返回 set 中对应值为 value 的迭代器，时间复杂度为O(logN)
//用法：
set&lt;int&gt;::iterator it = st.find(2); //在set中查找2,返回其迭代器
printf(&quot;%d\n&quot;, *it);
//以上两句也可以直接写成printf(&quot;%d\n&quot;, *(st.find(2)));
</code></pre>
<ol start="3">
<li>$ \text {erase()}$</li>
</ol>
<pre><code class="language-cpp">erase();
//erase()有两种用法：删除单个元素，删除一个区间内的所有元素
// 1. 删除单个元素
//删除单个元素的方法有两种
//st.erase(it), it为所需要删除元素的迭代器。时间复杂度为O(1)
st.erase(st.find(x));//利用find()函数找到x,然后用erase删除它

//st.erase(value), value为所需要删除元素的值。时间复杂度为O(logN)
st.erase(x);  //删除set中值为x的元素


// 2.删除一个区间内的所有元素
//st.erase(first, last)可以删除一个区间内的所有元素
//first为所需要删除区间的起始迭代器，last则为所需要删除区间的末尾迭代器的下一地址
//即删除[first, last)， 时间复杂度为O(last - first)
set&lt;int&gt;::iterator it1 = st.find(x);
set&lt;int&gt;::iterator it2 = st.find(y);
st.erase(it1, it2); //删除元素x至y之间的元素(包括x和y)
</code></pre>
<ol start="4">
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>size()</mtext></mrow><annotation encoding="application/x-tex">\text {size()}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">size()</span></span></span></span></span></li>
</ol>
<pre><code class="language-cpp">int x=size();//size()用来获得set内元素的个数，时间复杂度为O(1)
</code></pre>
<ol start="5">
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>clear()</mtext></mrow><annotation encoding="application/x-tex">\text {clear()}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">clear()</span></span></span></span></span></li>
</ol>
<pre><code class="language-cpp">set&lt;int&gt; s;
s.clear(); //清空set
</code></pre>
<h1 id="multiset">multiset</h1>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>set</mtext></mrow><annotation encoding="application/x-tex">\text {set}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord text"><span class="mord">set</span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>multiset</mtext></mrow><annotation encoding="application/x-tex">\text {multiset}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord">multiset</span></span></span></span></span> 会根据特定的排序原则将元素排序。两者不同之处在于， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>multiset</mtext></mrow><annotation encoding="application/x-tex">\text {multiset}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord">multiset</span></span></span></span></span> 允许元素重复，而 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>set</mtext></mrow><annotation encoding="application/x-tex">\text {set}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord text"><span class="mord">set</span></span></span></span></span> 不允许重复，其他操作和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>set</mtext></mrow><annotation encoding="application/x-tex">\text {set}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord text"><span class="mord">set</span></span></span></span></span> 都差不多的。</p>
<h1 id="map">map</h1>
<p>说白了就是一个动态的桶。</p>
<p>函数：</p>
<pre><code class="language-cpp">//应该只有这个要用到。。
map&lt;int,int&gt; mp;
mp.clear();//map初始化
</code></pre>
<h1 id="unordered_map">unordered_map</h1>
<p>使用方法和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>map</mtext></mrow><annotation encoding="application/x-tex">\text {map}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">map</span></span></span></span></span><strong>完全</strong>一样！</p>
<p>但是由于底层原理不同，它的查询是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>O(1)</mtext></mrow><annotation encoding="application/x-tex">\text {O(1)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">O(1)</span></span></span></span></span>的，而<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>map</mtext></mrow><annotation encoding="application/x-tex">\text {map}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">map</span></span></span></span></span>的查询却是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>O(log n)</mtext></mrow><annotation encoding="application/x-tex">\text {O(log n)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">O(log n)</span></span></span></span></span>的。</p>
<p>传闻这玩意要C++11才能用 ——假的！</p>
<p>一切都在标准C++范围内。</p>
<h1 id="bitset">bitset</h1>
<p>可以看作一个支持二进制数，每  位占用  个字节，并支持基本的位运算。</p>
<p>类型可以用  和整数初始化（整数转化成对应的二进制）。</p>
<p>举例：</p>
<pre><code>bitset&lt;23&gt;bit (string(&quot;11101001&quot;));
cout&lt;&lt;bit&lt;&lt;endl;
bit=233;
cout&lt;&lt;bit&lt;&lt;endl;
</code></pre>
<p>输出：</p>
<pre><code>00000000000000011101001
00000000000000011101001
</code></pre>
<p>这应该是用的最多的东西了，别的函数还有很多，这里就省略了（觉得没什么用。</p>
<h1 id="binary_search">binary_search</h1>
<p>函数模板：</p>
<pre><code class="language-cpp">binary_search(arr[], arr[]+size, indx);
</code></pre>
<p>参数说明：<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>arr[]</mtext></mrow><annotation encoding="application/x-tex">\text {arr[]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">arr[]</span></span></span></span></span> ：数组首地址<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>size</mtext></mrow><annotation encoding="application/x-tex">\text {size}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66786em;vertical-align:0em;"></span><span class="mord text"><span class="mord">size</span></span></span></span></span>：数组元素个数<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>indx</mtext></mrow><annotation encoding="application/x-tex">\text {indx}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord">indx</span></span></span></span></span>：需要查找的值<br>
函数功能： 在数组中以二分法检索的方式查找，若在数组(要求数组元素非递减)中查找到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>indx</mtext></mrow><annotation encoding="application/x-tex">\text {indx}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord">indx</span></span></span></span></span> 元素则真，若查找不到则返回值为假。</p>
<h1 id="lower_bound">lower_bound</h1>
<p><span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;_&#039; at position 13: \text {lower_̲bound(begin, en…'>\text {lower_bound(begin, end, num)}</span> ：从数组的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>begin</mtext></mrow><annotation encoding="application/x-tex">\text {begin}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">begin</span></span></span></span></span> 位置到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>end - 1</mtext></mrow><annotation encoding="application/x-tex">\text {end - 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord">end - 1</span></span></span></span></span>位置二分查找第一个大于或等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>num</mtext></mrow><annotation encoding="application/x-tex">\text {num}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord text"><span class="mord">num</span></span></span></span></span> 的数字，找到返回该数字的地址，不存在则返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>end</mtext></mrow><annotation encoding="application/x-tex">\text {end}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord">end</span></span></span></span></span> 。通过返回的地址减去起始地址<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>begin</mtext></mrow><annotation encoding="application/x-tex">\text {begin}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">begin</span></span></span></span></span> ，得到找到数字在数组中的下标。</p>
<pre><code class="language-cpp">int num[n+1];
pos=lower_bound(num+1,num+n+1,y)-num;    //返回数组num[1]到num[n]的元素中第一个大于或等于被查数的值的下标
</code></pre>
<h1 id="upper_bound">upper_bound</h1>
<p><span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;_&#039; at position 13: \text {upper_̲bound( begin,en…'>\text {upper_bound( begin,end,num)}</span> ：从数组的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>begin</mtext></mrow><annotation encoding="application/x-tex">\text {begin}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">begin</span></span></span></span></span> 位置到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>end - 1</mtext></mrow><annotation encoding="application/x-tex">\text {end - 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord">end - 1</span></span></span></span></span> 位置二分查找第一个小于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>num</mtext></mrow><annotation encoding="application/x-tex">\text {num}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord text"><span class="mord">num</span></span></span></span></span> 的数字，找到返回该数字的地址，不存在则返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>end</mtext></mrow><annotation encoding="application/x-tex">\text {end}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord">end</span></span></span></span></span> 。通过返回的地址减去起始地址 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>begin</mtext></mrow><annotation encoding="application/x-tex">\text {begin}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">begin</span></span></span></span></span> ，得到找到数字在数组中的下标。</p>
<pre><code class="language-cpp">int num[n+1];
pos=upper_bound(num+1,num+n+1,y)-num;    //返回数组num[1]到num[n]的元素中第一个大于被查数的值的下标
</code></pre>
<h1 id="reverse">reverse</h1>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>reverse()</mtext></mrow><annotation encoding="application/x-tex">\text {reverse()}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">reverse()</span></span></span></span></span> 函数可以对字符串进行反转操作。</p>
<p>容器类型的要用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>begin()</mtext></mrow><annotation encoding="application/x-tex">\text {begin()}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">begin()</span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>end()</mtext></mrow><annotation encoding="application/x-tex">\text {end()}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">end()</span></span></span></span></span> 来指定反转的区域，数组类型的直接用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>int</mtext></mrow><annotation encoding="application/x-tex">\text {int}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66786em;vertical-align:0em;"></span><span class="mord text"><span class="mord">int</span></span></span></span></span> 类型即可。</p>
<h3 id="使用方法">使用方法</h3>
<ol>
<li>交换 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>vector</mtext></mrow><annotation encoding="application/x-tex">\text {vector}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord text"><span class="mord">vector</span></span></span></span></span> 容器中元素顺序</li>
</ol>
<pre><code class="language-cpp">vector&lt;int&gt; v = {5,4,3,2,1};
reverse(v.begin(),v.end());//v的值为1,2,3,4,5
</code></pre>
<ol start="2">
<li>交换 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>string</mtext></mrow><annotation encoding="application/x-tex">\text {string}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8623000000000001em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">string</span></span></span></span></span> 字符串中元素的顺序</li>
</ol>
<pre><code class="language-cpp">string str=&quot;hello&quot;;
reverse(str.begin(),str.end());//str结果为olleh
</code></pre>
<ol start="3">
<li>交换字符数组 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>char[]</mtext></mrow><annotation encoding="application/x-tex">\text {char[]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">char[]</span></span></span></span></span> 中元素的顺序</li>
</ol>
<pre><code class="language-cpp">char a[101] = “hello world”;
reverse(a,a+strlen(a));
</code></pre>
<ol start="4">
<li>翻转一个数组</li>
</ol>
<pre><code class="language-cpp">int a[5+1]={0,1,2,3,4,5};
reverse(a+1,a+n+1);
</code></pre>
<h1 id="random_shuffle">random_shuffle</h1>
<p><span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;_&#039; at position 14: \text {random_̲shuffle()}'>\text {random_shuffle()}</span> 函数可以随机打乱容器内元素，用法和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>reverse()</mtext></mrow><annotation encoding="application/x-tex">\text {reverse()}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">reverse()</span></span></span></span></span> 相同。</p>
<pre><code class="language-cpp">int a[5+1]={0,1,2,3,4,5};
random_shuffle(a+1,a+n+1);
</code></pre>
<h1 id="next_permutation">next_permutation</h1>
<p><span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;_&#039; at position 12: \text {next_̲permutation}'>\text {next_permutation}</span> 是全排列函数。</p>
<p>用法比较少，下面是用这个函数实现全排列的代码：</p>
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;algorithm&gt;
using namespace std;
int main(){
    int n;
    while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n){
        int a[1000];
        for(int i=0;i&lt;n;i++){
            scanf(&quot;%d&quot;,&amp;a[i]);
        }
        sort(a,a+n);
        do{
            for(int i=0;i&lt;n;i++)
                printf(&quot;%d &quot;,a[i]);
            printf(&quot;\n&quot;);
        }while(next_permutation(a,a+n));
    }
    return 0;
}
</code></pre>
<h1 id="注意事项重要">注意事项（重要）：</h1>
<ol>
<li>除开 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>vector</mtext></mrow><annotation encoding="application/x-tex">\text {vector}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord text"><span class="mord">vector</span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>string</mtext></mrow><annotation encoding="application/x-tex">\text {string}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8623000000000001em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">string</span></span></span></span></span> 之外的STL容器都不支持 $*( \text {it} +\text  i) $ 的访问方式（这里 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>it</mtext></mrow><annotation encoding="application/x-tex">\text {it}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66786em;vertical-align:0em;"></span><span class="mord text"><span class="mord">it</span></span></span></span></span> 是迭代器）</li>
<li>大多数STL都需要特定的头文件，但是万能头是全部都包含的，为了方便，也为了安全，请使用万能头。</li>
</ol>
<h1 id="后记">后记</h1>
<p>对于初学者来说，STL尽量不要使用，要理解STL实现的原理，STL只是用于简化代码的，而不是用来当算法学习的。</p>
<p>STL就像是一个个封装好的工具，可以任你挑选使用，但是你需要先知道，哪个工具适合于你，也需要学会使用工具，这篇文章则是更偏向于讲后者。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[左偏树]]></title>
        <id>https://accepted.top/post/zuo-pian-shu/</id>
        <link href="https://accepted.top/post/zuo-pian-shu/">
        </link>
        <updated>2020-06-29T12:00:43.000Z</updated>
        <content type="html"><![CDATA[<p>左偏树</p>
<p>核心：merge函数</p>
<p>思想：</p>
<p>左偏树的合并是一个递归过程，对于以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 为根的树：</p>
<p>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 二者之一为空树，则返回另一棵。</p>
<p>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 均不为空，则比较 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 的权值大小。</p>
<p>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的权值较大，那么就把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 右儿子和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 合并的结果作为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 新的右儿子，返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> ；</p>
<p>否则就把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 交换，继续上面的操作。</p>
<p>合并以后由于我们还要维护左偏性质，即：如果合并后右儿子的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">dis</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span></span></span></span> 大于左儿子的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">dis</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span></span></span></span> ，则交换左右儿子。</p>
<p>这便是通过左偏树来实现可并堆的模拟过程。</p>
<p>代码：</p>
<pre><code class="language-cpp">int merge(int x,int y)
{
    if(!x) return y;
    if(!y) return x;
    if(v[x]&lt;v[y]) swap(x,y);
    rson[x]=merge(rson[x],y);
    if(dis[r[x]]&gt;dis[l[x]]) swap(lson[x],rson[x]);
    dis[x]=dis[rson[x]]+1;
    return x;
}
</code></pre>
<p>洛谷左偏树模板代码：</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 100010;
int n, m, op, x, y;
int lson[maxn], rson[maxn], dist[maxn], fa[maxn];
bool tf[maxn];
struct node{
	int id, v;
	bool operator&lt;(node x) const { 
		return v == x.v ? id &lt; x.id : v &lt; x.v; 
	}
} v[maxn];
int find(int x){ 
	return fa[x] == x ? x : fa[x] = find(fa[x]); 
}
int merge(int x, int y){
	if (!x || !y)
		return x + y;
	if (v[y] &lt; v[x])
		swap(x, y);
	rson[x] = merge(rson[x], y);
	if (dist[lson[x]] &lt; dist[rson[x]])
		swap(lson[x], rson[x]);
	dist[x] = dist[rson[x]] + 1;
	return x;
}
int main()
{
	dist[0] = -1;
	read(n);
	read(m);
	For(i,1,n)
		read(v[i].v), fa[i] = i, v[i].id = i;
	while (m--)
	{
		read(op);
		read(x);
		if (op == 1)
		{
			read(y);
			if (tf[x] || tf[y])
				continue;
			x = find(x);
			y = find(y);
			if (x != y)
				fa[x] = fa[y] = merge(x, y);
		}
		if (op == 2)
		{
			if (tf[x])
			{
				printf(&quot;-1\n&quot;);
				continue;
			}
			x = find(x);
			printf(&quot;%d\n&quot;, v[x].v);
			tf[x] = true;
			fa[lson[x]] = fa[rson[x]] = fa[x] = merge(lson[x], rson[x]);
			lson[x] = rson[x] = dist[x] = 0;
		}
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[struct重载运算符用法]]></title>
        <id>https://accepted.top/post/struct-chong-zai-yun-suan-fu-yong-fa/</id>
        <link href="https://accepted.top/post/struct-chong-zai-yun-suan-fu-yong-fa/">
        </link>
        <updated>2020-06-29T06:43:30.000Z</updated>
        <content type="html"><![CDATA[<p>operator是c++的重载运算符，字面意思，自己理解。</p>
<p>一般回放在struct结构体当中，可以直接把结构体中的变量用运算符搞，挺方便的。</p>
<p>重载运算符的格式如下：</p>
<p>bool operator 运算符 (const 结构体名称 b) const</p>
<p>{<br>
return(什么时候这个运算符对结构体成立);//注意对此运算符使用this-&gt;元素名；</p>
<p>}</p>
<p>举例</p>
<pre><code class="language-cpp">struct point
{
	    int elem;
	    bool operator&lt;(point b)const
    	{
	    	    return elem&gt;b.elem;
	    }
};

</code></pre>
]]></content>
    </entry>
</feed>