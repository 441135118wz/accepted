<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://accepted.top</id>
    <title>accepted&apos;s blog</title>
    <updated>2020-10-16T04:29:37.597Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://accepted.top"/>
    <link rel="self" href="https://accepted.top/atom.xml"/>
    <logo>https://accepted.top/images/avatar.png</logo>
    <icon>https://accepted.top/favicon.ico</icon>
    <rights>All rights reserved 2020, accepted&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[他是 ISIJ 第四名，也是在线知名题库的洛谷“网红”]]></title>
        <id>https://accepted.top/post/ta-shi-isij-di-si-ming-ye-shi-zai-xian-zhi-ming-ti-ku-de-luo-gu-wang-hong/</id>
        <link href="https://accepted.top/post/ta-shi-isij-di-si-ming-ye-shi-zai-xian-zhi-ming-ti-ku-de-luo-gu-wang-hong/">
        </link>
        <updated>2020-10-16T04:28:44.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2020/10/16/wpL4loVXdH1vnIe.jpg" alt="f273d6cbce54482ebfa1a9c11dad2357.jpeg" loading="lazy"></figure>
<p>2020年国际初中生信息学竞赛（ISIJ）上，以优秀成绩拿下第四名年仅初三的张湫阳，成为最夺目的选手之一。</p>
<p>而且虽然是初三的选手，但他取得优异成绩后，不少网友并不感到陌生，纷纷留言：</p>
<p>这不是洛谷上天天爆切神仙题的小哥吗？</p>
<p>没错，和其他ISIJ选手不同，张湫阳之前在网络上就已经小有名气，可以说是洛谷上的“网红”。</p>
<p>他的洛谷账号Follow人数刚刚突破一万大关，洛谷的估值排名也常年稳居前五，还有一个粉丝群。</p>
<p>这样的数据放在国内也是妥妥的知识区网红了。</p>
<figure data-type="image" tabindex="2"><img src="https://i.loli.net/2020/10/16/hobtIsYg9lQxuAF.png" alt="ft.PNG" loading="lazy"></figure>
<p>ISIJ一个月前，张湫阳更是在个人的洛谷博客上发布一篇博客，是ISIJ集训队的作业，并且在博客的最后放下豪言“近几年的IOI题都是傻逼题”。</p>
<p>一位“不明真相”的网友还评价说，ISIJ金牌只有1%的机会能获得，“我愿意以1:99的赔率打赌”。</p>
<figure data-type="image" tabindex="3"><img src="https://i.loli.net/2020/10/16/Nt9nqfKFIhCGuxw.png" alt="QQ图片20201016080613.png" loading="lazy"></figure>
<p>这位网友不知道的是，张湫阳去年第一次参加CSP就获得了400分以上的好成绩，吊打了全国大部分的选手。</p>
<p>现在该评论已经被张湫阳删除，不知道这位网友作何感想。</p>
<p>另外，与国内诸多IOI金牌学霸一样的是，张湫阳也收到了名校通知书。</p>
<p>国内有不少IOI金牌得主被清华姚班选择，张湫阳则是被绍兴市第一中学录取。</p>
<p>对于仅仅年满15岁的他来说，一切都才刚开始。</p>
<h3 id="两年前开始编程生涯">两年前开始编程生涯</h3>
<p>张湫阳对编程产生的兴趣起源很早，两年前就开始在洛谷注册了一个账号，通过的第一个题目是A+B Problem。</p>
<figure data-type="image" tabindex="4"><img src="https://i.loli.net/2020/10/16/E2qfU1doaAQLDkW.png" alt="QQ图片20201016080833.png" loading="lazy"></figure>
<p>他的洛谷博客也创作始于2年前，上传的第一篇博客是<a href="https://www.luogu.com.cn/blog/froggy/solution-p1498">题解 P1498 【南蛮图腾】</a>。</p>
<p>这个博客一直没有什么热度，直到去年他获得过CSP 400分以上的成绩后，才收获了第一条回复。</p>
<p>直到后来，从一年前开始，他在AtCoder编程竞赛网站上刷题，一下子变成了高产播主，接连上传了近30个博客。</p>
<p>其中点赞数最高的是他写的AGC 045 的题解，点赞数即将突破一万大关。</p>
<figure data-type="image" tabindex="5"><img src="https://i.loli.net/2020/10/16/64KNrwz2BcRF3YA.png" alt="fr.PNG" loading="lazy"></figure>
<p>对于编程爱好者来说，这个只有文字的博客可以说是全程高能。因为AtCoder给了2.5个小时的时间，而张湫阳在赛后补题的时候只用16分5秒就解决了所有问题，毫无疑问如果参加比赛，将把所有选手踩在脚下。</p>
<figure data-type="image" tabindex="6"><img src="https://i.loli.net/2020/10/16/QK16Od8PLlsem5v.png" alt="QQ图片20201016082023.png" loading="lazy"></figure>
<p>下图是正式参赛选手的比赛时候的榜，前几位的选手都是世界排名前几的知名选手，多来自世界顶级大学，例如ksun48来自就来自美国的顶级学府MIT。</p>
<figure data-type="image" tabindex="7"><img src="https://i.loli.net/2020/10/16/gB51UAyzxsSJmQa.png" alt="QQ图片20201016083208.png" loading="lazy"></figure>
<p>有网友看完这个博客后说：Froggy可以在20分钟内解决AGC 045的编程竞赛题，而我20分钟连A题的题目都看不懂。</p>
<figure data-type="image" tabindex="8"><img src="https://i.loli.net/2020/10/16/YnDNL6oVqXy1SJa.png" alt="s2.PNG" loading="lazy"></figure>
<p>能如此耐心解答问题，引来一些爱好编程的学生“催更”：请上传所有比赛题解好吗？</p>
<figure data-type="image" tabindex="9"><img src="https://i.loli.net/2020/10/16/lNc6wbCDyMEFSIh.png" alt="s1.PNG" loading="lazy"></figure>
<h3 id="从河南省队逆袭到全球第四">从河南省队逆袭到全球第四</h3>
<p>当被问及怎么样才能才能成为一个好的程序员（computer programmer，CP）时，张湫阳只给了一个建议：</p>
<blockquote>
<p>除非像我一样天赋异禀，否则不可能！</p>
</blockquote>
<p>因为，他本人就是这么天才。</p>
<p>事实上，张湫阳在ISIJ前就参加了ccf NOI系列赛事河南省的省队选拔，但第一次比赛的过程，并没有想象中那般顺利。</p>
<p>在HAOI2020中，张湫阳总分只有310分。当然，这样的成绩，也足以让他进入省队。</p>
<p>但张湫阳并不满足于这样的水平。在那之后，到今年参加ISIJ前，他开始在CodeForces上刷题。</p>
<p>为了准备ISIJ，张湫阳甚至不惜不参加中考的复习，把中考前的复习时间全部投入到了ISIJ的备战当中。</p>
<p>有时候甚至一天十几题：</p>
<figure data-type="image" tabindex="10"><img src="https://i.loli.net/2020/10/16/OBWxHTSzl19t7JC.png" alt="QQ图片20201016083913.png" loading="lazy"></figure>
<p>而且，如果返回Accepted，他会要求自己重新重写一遍代码，直到得到比标算更优的解为止。</p>
<figure data-type="image" tabindex="11"><img src="https://i.loli.net/2020/10/16/sWMQPlCeIxD3w2K.png" alt="QQ图片20201016085018.png" loading="lazy"></figure>
<p>上图是张湫阳通过了CodeForces最难的几个问题之一的提交记录，可以看到张湫阳后来的提交速度整整快了5秒。</p>
<p>此外，张湫阳也没有忘记参加各种编程竞赛，不断积累经验。</p>
<p>例如，在今年，张湫阳就参加了AtCoder举办的编程竞赛AtCoder Grand Contest 044、由清华大学计算机系学生算法与竞赛协会联合学堂在线举办的高水平系列赛事“code+程序设计网络挑战赛”。</p>
<p>并且在这些比赛中，张湫阳都获得了非常优秀的成绩，他还在社交平台上说：“这些比赛好水啊，不会真有人不能阿克吧？”。</p>
<figure data-type="image" tabindex="12"><img src="https://i.loli.net/2020/10/16/Gk9HNyR1jtF6vOP.png" alt="QQ图片20201016091300.png" loading="lazy"></figure>
<p>也就是说，张湫阳会利用各个空余的时间，去到处比赛、刷题。</p>
<p>这样的努力也终于给他带来了丰硕的成果。</p>
<p>今年7月，张湫阳终于在今年拿下ISIJ金牌，并且是全球第四名。</p>
<h3 id="游戏时间勿扰">“游戏时间，勿扰”</h3>
<p>然而，张湫阳并不像大众看起来那般“大神”——一天24小时都在学习。</p>
<p>事实上，他也与许多人一样，会在闲暇时间与朋友玩耍、甚至是打游戏。</p>
<p>例如，在准备ISIJ的训练中，每天下午四点张湫阳会准时和同学一起去打乒乓球，强身健体的同时，也能让自己的眼睛得到休息。</p>
<p>此外，在他平时训练累的时候，还会时不时打两局“逃跑吧！少年”。</p>
<p>张湫阳在休息与学习中划分了一条非常明确的界限：用心地学，也要尽兴玩。</p>
<p>此外，张湫阳还建立了自己的服务器，希望能在这里与热爱编程的人们一起讨论各种有意思的竞赛题目（Codeforces, CodeChef, AtCoder）、面试（LeetCode）和奥赛相关的话题（IOI, NOI）。</p>
<p>不过，他要求粉丝们公开膜拜自己，这个不难从他博客下方的评论看出：</p>
<figure data-type="image" tabindex="13"><img src="https://i.loli.net/2020/10/16/WOBEoXnMhs87UZH.png" alt="QQ图片20201016085643.png" loading="lazy"></figure>
<p>这是个非常开放的社区，除了编程、面试与竞赛以外，社区里也有讨论各种音乐、游戏与基础学科的栏目。</p>
<p>当然，还有专设的meme（表情包）分享栏。</p>
<p>事实上，张湫阳平日里也很幽默，会在社交媒体上分享自己做的meme。</p>
<figure data-type="image" tabindex="14"><img src="https://i.loli.net/2020/10/16/cagFjLTNyDVUX7S.png" alt="QQ图片20201016092227.png" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[sth to learn]]></title>
        <id>https://accepted.top/post/sth-to-learn/</id>
        <link href="https://accepted.top/post/sth-to-learn/">
        </link>
        <updated>2020-07-31T00:09:58.000Z</updated>
        <content type="html"><![CDATA[<p>容斥定理</p>
<p>网络流</p>
<p>点分治</p>
<p>trie树</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于友链]]></title>
        <id>https://accepted.top/post/guan-yu-you-lian/</id>
        <link href="https://accepted.top/post/guan-yu-you-lian/">
        </link>
        <updated>2020-07-24T11:05:48.000Z</updated>
        <content type="html"><![CDATA[<p>欢迎各位大佬来加我的友链。<br>
我的评论区已经做好了，如有需求可以评论区留言，我看到会回复的！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于此博客]]></title>
        <id>https://accepted.top/post/guan-yu-ci-bo-ke/</id>
        <link href="https://accepted.top/post/guan-yu-ci-bo-ke/">
        </link>
        <updated>2020-07-22T03:41:13.000Z</updated>
        <content type="html"><![CDATA[<p>欢迎来看我的博客。</p>
<p>这个博客是我用来写一些算法，题解的。</p>
<p>因为博主很菜，所以文章写的不会很严谨，有什么写的不对的地方还请细心的读者指出。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[7.8模拟赛题解]]></title>
        <id>https://accepted.top/post/78-mo-ni-sai-ti-jie/</id>
        <link href="https://accepted.top/post/78-mo-ni-sai-ti-jie/">
        </link>
        <updated>2020-07-08T11:49:51.000Z</updated>
        <content type="html"><![CDATA[<p>一场爆0模拟赛的垃圾题解。</p>
<p><a href="https://441135118wz.github.io/accepted/post/78-mo-ni-sai-ti-mu/">题面传送门</a></p>
<h3 id="t1">T1：</h3>
<p>T1没有原题，，题意说的还是很清楚，但是考试的时候没有想到用2分。。</p>
<p>这题是2分答案，就是二分需要的天数，只要想到思路，代码还是很短的。</p>
<p>启示：一般让你求最小的答案都可以往二分这方面去想想。</p>
<p>都弄成中位数还是很好证明的，也很常见。</p>
<p>这里先介绍一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>STL</mtext></mrow><annotation encoding="application/x-tex">\text{STL}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">STL</span></span></span></span></span> : <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>t</mi><mi>h</mi><mi mathvariant="normal">_</mi><mi>e</mi><mi>l</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mo>(</mo><mi>b</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>b</mi><mo>+</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo separator="true">,</mo><mi>b</mi><mo>+</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">nth\_element(b+1,b+mid,b+n+1);</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">;</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>o</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">o(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">o</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>找中位数，还是挺好用的。</p>
<p>分析也很难说（更主要是懒），看代码理解一下就好了</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
ll n,q[500005],b[500005];
inline bool check(ll x){
    ll y=x/n,ans=0,mid=(n+1)&gt;&gt;1ll;
    For(i,1,n) b[i]=q[i]+y;
    For(i,1,x%n) b[i]++;
    nth_element(b+1,b+mid,b+n+1);
    For(i,1,n) ans+=abs(b[mid]-b[i]);
    return ans&lt;=x;
}
int main(){
    freopen(&quot;raft.in&quot;,&quot;r&quot;,stdin);
	freopen(&quot;raft.out&quot;,&quot;w&quot;,stdout);
    ll ans;
    read(n);
    For(i,1,n) read(q[i]);
    ll l=1,r=1e15;
    while(l&lt;=r){
        ll mid=(l+r)&gt;&gt;1ll;
        if(check(mid)) r=mid-1,ans=mid;
        else l=mid+1;
    }
    write(ans);
}
</code></pre>
<h3 id="t2">T2:</h3>
<p>T2这题一眼看感觉不是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>dp</mtext></mrow><annotation encoding="application/x-tex">\text{dp}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">dp</span></span></span></span></span> ，感觉后面的选择会影响前面的。（充分体现了直觉的不准。。）</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span></span></span></span> 思路：</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 表示先手拿 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>−</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i-j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 的区间的最大差值。</p>
<p>每一个区间都可以看成一方先手拿走左边 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 个或右边 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 个（ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 是任意数），再 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>dp</mtext></mrow><annotation encoding="application/x-tex">\text {dp}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">dp</span></span></span></span></span> 剩下的那个区间就好了。</p>
<p>这题应该介于记忆化和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>dp</mtext></mrow><annotation encoding="application/x-tex">\text {dp}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">dp</span></span></span></span></span> 之间的吧。</p>
<p>聪明的读者应该会有一个问题，就是在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>dp</mtext></mrow><annotation encoding="application/x-tex">\text{dp}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">dp</span></span></span></span></span> 的过程中会有先后手的区别。</p>
<p>你可以看成一段区间内的区间的dp值是 当对面为先手的时候的差值，（感性理解一下）</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>−</mo><mi>b</mi><mo>=</mo><mo>−</mo><mo>(</mo><mi>b</mi><mo>−</mo><mi>a</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">a-b=-(b-a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mclose">)</span></span></span></span> ，所以减去就好了。</p>
<p>代码：</p>
<pre><code class="language-cpp">int n;
int q[1005],sum[1005],d[1005][1005];
int dfs(int l,int r){
	if(l&gt;r) return 0;
	if(l==r) return d[l][r]=q[l];
	if(d[l][r]!=-INF) return d[l][r];
	For(i,1,r-l+1){
		d[l][r]=max(d[l][r],sum[l+i-1]-sum[l-1]-dfs(l+i,r));
	}
	For(i,1,r-l+1){
		d[l][r]=max(d[l][r],sum[r]-sum[r-i]-dfs(l,r-i));
	}
	return d[l][r];
}
int main(){
	freopen(&quot;farcry.in&quot;,&quot;r&quot;,stdin);
	freopen(&quot;farcry.out&quot;,&quot;w&quot;,stdout);
	while(1){
		For(i,0,100) q[i]=0,sum[i]=0;
		For(i,0,100)
		For(j,0,100) d[i][j]=-INF;
		read(n);
		if(!n) return 0;
		For(i,1,n) read(q[i]),sum[i]=sum[i-1]+q[i];
		write(dfs(1,n));
		puts(&quot;&quot;);
	}
}
</code></pre>
<h3 id="t3">T3:</h3>
<p>​	垃圾结论题。</p>
<p>​	这题只要知道歌德巴赫猜想就好了。（不会证没关系，反正在1e18的范围内已经证明了，可以当结论用的。）</p>
<ol>
<li>每个大于2的偶数都是两个素数之和。</li>
<li>每个大于5的奇数都是三个素数之和。</li>
</ol>
<p>所以答案肯定是1 2 3中间一个。</p>
<p>就直接上代码了。。</p>
<pre><code class="language-cpp">inline bool check(ll a){
	if(a%2==0) return false;
	for(int i=3;i&lt;=sqrt(a)+1;i+=2)
		if(a%i==0) return false;
	return true;
}
signed main(){
	freopen(&quot;taxes.in&quot;,&quot;r&quot;,stdin);
	freopen(&quot;taxes.out&quot;,&quot;w&quot;,stdout);
	int T;
	ll q,ans=0;
	T=read();
	while(T--){
		q=read();
		if(q==2||check(q))cout&lt;&lt;1&lt;&lt;endl;
		else if(q%2==0||(check(q-2))) cout&lt;&lt;2&lt;&lt;endl;
		else cout&lt;&lt;3&lt;&lt;endl;
	}
	
	return 0;
}
</code></pre>
<h3 id="t4">T4：</h3>
<p>原题：<a href="https://www.luogu.com.cn/problem/CF786B">CF786B</a></p>
<p>目前还不会，留坑。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[KMP算法学习小结]]></title>
        <id>https://accepted.top/post/kmp-suan-fa-xue-xi-xiao-jie/</id>
        <link href="https://accepted.top/post/kmp-suan-fa-xue-xi-xiao-jie/">
        </link>
        <updated>2020-07-07T12:07:36.000Z</updated>
        <content type="html"><![CDATA[<h3 id="前言">前言</h3>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>KMP</mtext></mrow><annotation encoding="application/x-tex">\text {KMP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">KMP</span></span></span></span></span> 是我觉得比较难理解的算法之一。</p>
<p>具体可以去别的博客里去多了解一下，这里具体讲思路。</p>
<p>我看过的大多数博客都写的很学术，很长，既没有能力也没有耐心去看，所以这东西就被认为难学。</p>
<p>其实还是挺简单的吧。</p>
<p>所谓失配指针，就是指向在当前字符的前面的离他最近且和它相等的字符的坐标。</p>
<p>设要求字符串 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>a</mtext></mrow><annotation encoding="application/x-tex">\text a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord text"><span class="mord">a</span></span></span></span></span> 里有多少个子串等于字符串 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>b</mtext></mrow><annotation encoding="application/x-tex">\text {b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord">b</span></span></span></span></span> 。</p>
<h3 id="算法流程">算法流程</h3>
<ol>
<li>
<p>我们先预处理失配指针，具体实现和理解下面会讲。</p>
</li>
<li>
<p>然后用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 个指针 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> ， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 扫 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 字符串， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 扫 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 字符串，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>j</mtext><mo>=</mo><mo>(</mo><mtext> j</mtext></mrow><annotation encoding="application/x-tex">\text j= (\ \text j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8623000000000001em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">j</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mspace"> </span><span class="mord text"><span class="mord">j</span></span></span></span></span> 的失配指针 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>)</mo></mrow><annotation encoding="application/x-tex">)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">)</span></span></span></span> 直到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">j=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的时候或者 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo>[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">b[j+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 等于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">a[i+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> ，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo>+</mo><mo>+</mo></mrow><annotation encoding="application/x-tex">j++</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">+</span></span></span></span> 。</p>
</li>
<li>
<p>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 的长度，就已经匹配了。</p>
</li>
<li>
<p>如果你需要没有重叠的字串， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 归零，不然，就再等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 的失配指针。</p>
</li>
</ol>
<h3 id="失配指针原理">失配指针原理</h3>
<p>用人话说，就是上面那句话：指向在当前字符的前面的离他最近且和它相等的字符的坐标。</p>
<p>再直观一点，画个图（画的有点丑，要怪就怪学校的鼠标不好用吧）</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.luogu.com.cn/upload/image_hosting/ffuzwmr5.png" alt="" loading="lazy"></figure>
<p>理解后，就先来说 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>KMP</mtext></mrow><annotation encoding="application/x-tex">\text {KMP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">KMP</span></span></span></span></span> 匹配的部分吧，上面已经说了具体的步骤，这里给一下代码：</p>
<pre><code class="language-cpp">int kmp(){
    int j=0;
    for(int i=0;i&lt;lenb;++i){
        while(j&gt;0&amp;&amp;b[i+1]!=a[j+1]) j=p[j];
        if(b[i+1]==a[j+1]) j++;//上面和这行对应第二步，这里懒得加注释了。
        
        if(j==lena){
            ans++;//这个随意
            //cout&lt;&lt;i+2-lena&lt;&lt;endl;
            j=p[j];//这里看具体题目，现在是允许有重叠部分的字串，如果不允许j要变成0
        }
        
    }
}
</code></pre>
<p>现在再来说说预处理失配指针的思路。</p>
<p>其实和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>KMP</mtext></mrow><annotation encoding="application/x-tex">\text {KMP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">KMP</span></span></span></span></span> 的代码差不多，是自己匹配自己。</p>
<h3 id="流程">流程</h3>
<ol>
<li>用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 个指针 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> ， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>j</mtext><mo>=</mo><mo>(</mo><mtext> j</mtext></mrow><annotation encoding="application/x-tex">\text j= (\ \text j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8623000000000001em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">j</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mspace"> </span><span class="mord text"><span class="mord">j</span></span></span></span></span> 的失配指针 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>)</mo></mrow><annotation encoding="application/x-tex">)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">)</span></span></span></span> 直到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">j=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的时候或者 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo>[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">b[j+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 等于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo>[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">b[i+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> ，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo>+</mo><mo>+</mo></mrow><annotation encoding="application/x-tex">j++</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">+</span></span></span></span> 。</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">b[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 的失配指针指向的就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 。</li>
</ol>
<h5 id="代码">代码：</h5>
<pre><code class="language-cpp">void pre(){
    p[1]=0;
    int j=0;
    for(int i=1;i&lt;lena;++i){
        while(j&gt;0&amp;&amp;a[j+1]!=a[i+1]) j=p[j];
        if(a[j+1]==a[i+1]) j++;
        p[i+1]=j;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[to do!]]></title>
        <id>https://accepted.top/post/to-do/</id>
        <link href="https://accepted.top/post/to-do/">
        </link>
        <updated>2020-07-05T07:11:11.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>DP</li>
<li>线段树</li>
<li>网络流</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P3147题解]]></title>
        <id>https://accepted.top/post/p3147-ti-jie/</id>
        <link href="https://accepted.top/post/p3147-ti-jie/">
        </link>
        <updated>2020-07-02T12:20:50.000Z</updated>
        <content type="html"><![CDATA[<p>题目传送门：<a href="https://www.luogu.com.cn/problem/P3147">P3147</a></p>
<h3 id="前言">前言</h3>
<p>这题是区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>dp</mtext></mrow><annotation encoding="application/x-tex">\text {dp}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">dp</span></span></span></span></span> <strong>绿</strong>题， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>dp</mtext></mrow><annotation encoding="application/x-tex">\text{dp}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">dp</span></span></span></span></span> 还是有点难想的。</p>
<p>一开始觉得和合并石子差不多，后来看了看<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>≤</mo><mn>262144</mn></mrow><annotation encoding="application/x-tex">N\le 262144</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">6</span><span class="mord">2</span><span class="mord">1</span><span class="mord">4</span><span class="mord">4</span></span></span></span>，就不会了，于是去看了题解。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>表示以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 为左端点合并出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 时的右端点。</p>
<p>一看到这个式子的时候，觉得挺奇怪的。</p>
<p>这个用到了类似于倍增的思想，如果所有数都是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>40</mn></mrow><annotation encoding="application/x-tex">40</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">0</span></span></span></span> 的话，最大合出来的数是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>58</mn></mrow><annotation encoding="application/x-tex">58</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">8</span></span></span></span> 。所以就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>58</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">58n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">8</span><span class="mord mathdefault">n</span></span></span></span> 的复杂度。</p>
<p>妙啊！妙啊！</p>
<h3 id="递推式">递推式</h3>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]=dp[i-1][dp[i-1][j]]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mclose">]</span></span></span></span></p>
<p>解释：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[i-1][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 为左端点合并出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 时的右端点， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[i-1][dp[i-1][j]]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mclose">]</span></span></span></span> 就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 堆 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 合起来，这个原理和合并石子差不多的。</p>
<h3 id="初始化">初始化</h3>
<pre><code class="language-cpp">For(i,1,n) dp[q=read()][i]=i+1;//以i为左端点合并出 q 时的右端点是i+1
</code></pre>
<h3 id="代码">代码</h3>
<pre><code class="language-cpp">int main() {
    read(n);
    For(i,1,n) read(q),f[q][i]=i+1;
    For(i,1,58)
    For(j,1,n){
        if(!f[i][j]) f[i][j]=f[i-1][f[i-1][j]];
        if(f[i][j]) ans=i;
    }
    write(ans);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P1637 三元上升子序列 题解]]></title>
        <id>https://accepted.top/post/p1637-san-yuan-shang-sheng-zi-xu-lie-ti-jie/</id>
        <link href="https://accepted.top/post/p1637-san-yuan-shang-sheng-zi-xu-lie-ti-jie/">
        </link>
        <updated>2020-07-02T02:28:36.000Z</updated>
        <content type="html"><![CDATA[<p>题目传送门：<a href="https://www.luogu.com.cn/problem/P1637">三元上升子序列</a></p>
<p>这道题先需要想到一个结论，就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mo>∗</mo><mo>(</mo><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo><mi mathvariant="normal">左</mi><mi mathvariant="normal">边</mi><mi mathvariant="normal">比</mi><mi mathvariant="normal">他</mi><mi mathvariant="normal">小</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">量</mi><mo>)</mo><mo>∗</mo><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo><mi mathvariant="normal">右</mi><mi mathvariant="normal">边</mi><mi mathvariant="normal">比</mi><mi mathvariant="normal">他</mi><mi mathvariant="normal">大</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">量</mi></mrow><annotation encoding="application/x-tex">ans=\sum_{i=1}^{n}*(a[i]左边比他小的数的数量)*a[i]右边比他大的数的数量</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∗</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mord cjk_fallback">左</span><span class="mord cjk_fallback">边</span><span class="mord cjk_fallback">比</span><span class="mord cjk_fallback">他</span><span class="mord cjk_fallback">小</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">量</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mord cjk_fallback">右</span><span class="mord cjk_fallback">边</span><span class="mord cjk_fallback">比</span><span class="mord cjk_fallback">他</span><span class="mord cjk_fallback">大</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">量</span></span></span></span>。</p>
<p>就可以先离散化再2次树状数组就好了。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
int a[200005],b[200005],ans;
int fuck1[200005],fuck2[200005],n,len;
int Left[200005],Right[200005];//开小数组见祖宗 
inline int lowbit(int x){return x&amp;-x;}
inline int add1(int x){for(int i=x;i&lt;=len;i+=lowbit(i))fuck1[i]++;}
inline int add2(int x){for(int i=x;i&lt;=len;i+=lowbit(i))fuck2[i]++;}
inline int ask1(int x){int sum=0;for(int i=x;i;i-=lowbit(i)){sum+=fuck1[i];} return sum;}
inline int ask2(int x){int sum=0;for(int i=x;i;i-=lowbit(i)){sum+=fuck2[i];} return sum;}
signed main() {
    freopen(&quot;T2.in&quot;,&quot;r&quot;,stdin);
    freopen(&quot;T2.out&quot;,&quot;w&quot;,stdout);
	read(n);
	For(i,1,n)read(a[i]),b[i]=a[i];
	
    sort(b+1,b+n+1);
	len=unique(b+1,b+n+1)-b-1;
	For(i,1,n) a[i]=lower_bound(b+1,b+len+1,a[i])-b;//离散化

	For(i,1,n) add1(a[i]),Left[i]=ask1(a[i]-1);
	for(int i=n;i&gt;=1;--i) add2(a[i]),Right[i]=ask2(len)-ask2(a[i]);
    
	For(i,1,n) ans+=Left[i]*Right[i];
	write(ans);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树状数组求逆序对]]></title>
        <id>https://accepted.top/post/shu-zhuang-shu-zu-qiu-ni-xu-dui/</id>
        <link href="https://accepted.top/post/shu-zhuang-shu-zu-qiu-ni-xu-dui/">
        </link>
        <updated>2020-07-01T13:18:00.000Z</updated>
        <content type="html"><![CDATA[<p>从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 枚举，考虑当前枚举到的位置 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> ，他对总的逆序对的个数的贡献就是他前面的权值大于他的权值的数的个数，所以我们在i的权值的位置修改树状数组，表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 的权值这个数已经出现过了，那么到了后面就可以直接查询从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 的权值的位置的总和。</p>
<pre><code class="language-cpp">void add(int i,int t){
    while(i&lt;=len){//这里的len是元素种类，具体见上一篇博客
        c[i]+=t;
        i+=lowbit(i);
    }
}
int main(){
    int n;
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++){
        int t;
        cin&gt;&gt;t;
        add(t,1);
        ans+=i-sum(t);
    }
    for(int i=1;i&lt;=n;i++){
        cout&lt;&lt;c[i]&lt;&lt;endl;
    }
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>