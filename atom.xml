<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://441135118wz.github.io/accepted</id>
    <title>ori&apos;s blog</title>
    <updated>2020-07-05T07:12:30.706Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://441135118wz.github.io/accepted"/>
    <link rel="self" href="https://441135118wz.github.io/accepted/atom.xml"/>
    <logo>https://441135118wz.github.io/accepted/images/avatar.png</logo>
    <icon>https://441135118wz.github.io/accepted/favicon.ico</icon>
    <rights>All rights reserved 2020, ori&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[to do!]]></title>
        <id>https://441135118wz.github.io/accepted/post/to-do/</id>
        <link href="https://441135118wz.github.io/accepted/post/to-do/">
        </link>
        <updated>2020-07-05T07:11:11.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>DP</li>
<li>树上差分</li>
<li>线段树</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P3147题解]]></title>
        <id>https://441135118wz.github.io/accepted/post/p3147-ti-jie/</id>
        <link href="https://441135118wz.github.io/accepted/post/p3147-ti-jie/">
        </link>
        <updated>2020-07-02T12:20:50.000Z</updated>
        <content type="html"><![CDATA[<p>题目传送门：<a href="https://www.luogu.com.cn/problem/P3147">P3147</a></p>
<h3 id="前言">前言</h3>
<p>这题是区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>dp</mtext></mrow><annotation encoding="application/x-tex">\text {dp}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">dp</span></span></span></span></span> <strong>绿</strong>题， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>dp</mtext></mrow><annotation encoding="application/x-tex">\text{dp}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">dp</span></span></span></span></span> 还是有点难想的。</p>
<p>一开始觉得和合并石子差不多，后来看了看<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>≤</mo><mn>262144</mn></mrow><annotation encoding="application/x-tex">N\le 262144</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">6</span><span class="mord">2</span><span class="mord">1</span><span class="mord">4</span><span class="mord">4</span></span></span></span>，就不会了，于是去看了题解。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>表示以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 为左端点合并出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 时的右端点。</p>
<p>一看到这个式子的时候，觉得挺奇怪的。</p>
<p>这个用到了类似于倍增的思想，如果所有数都是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>40</mn></mrow><annotation encoding="application/x-tex">40</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">0</span></span></span></span> 的话，最大合出来的数是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>58</mn></mrow><annotation encoding="application/x-tex">58</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">8</span></span></span></span> 。所以就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>58</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">58n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">8</span><span class="mord mathdefault">n</span></span></span></span> 的复杂度。</p>
<p>妙啊！妙啊！</p>
<h3 id="递推式">递推式</h3>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]=dp[i-1][dp[i-1][j]]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mclose">]</span></span></span></span></p>
<p>解释：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[i-1][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 为左端点合并出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 时的右端点， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[i-1][dp[i-1][j]]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mclose">]</span></span></span></span> 就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 堆 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 合起来，这个原理和合并石子差不多的。</p>
<h3 id="初始化">初始化</h3>
<pre><code class="language-cpp">For(i,1,n) dp[q=read()][i]=i+1;//以i为左端点合并出 q 时的右端点是i+1
</code></pre>
<h3 id="代码">代码</h3>
<pre><code class="language-cpp">int main() {
    read(n);
    For(i,1,n) read(q),f[q][i]=i+1;
    For(i,1,58)
    For(j,1,n){
        if(!f[i][j]) f[i][j]=f[i-1][f[i-1][j]];
        if(f[i][j]) ans=i;
    }
    write(ans);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P1637 三元上升子序列 题解]]></title>
        <id>https://441135118wz.github.io/accepted/post/p1637-san-yuan-shang-sheng-zi-xu-lie-ti-jie/</id>
        <link href="https://441135118wz.github.io/accepted/post/p1637-san-yuan-shang-sheng-zi-xu-lie-ti-jie/">
        </link>
        <updated>2020-07-02T02:28:36.000Z</updated>
        <content type="html"><![CDATA[<p>题目传送门：<a href="https://www.luogu.com.cn/problem/P1637">三元上升子序列</a></p>
<p>这道题先需要想到一个结论，就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mo>∗</mo><mo>(</mo><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo><mi mathvariant="normal">左</mi><mi mathvariant="normal">边</mi><mi mathvariant="normal">比</mi><mi mathvariant="normal">他</mi><mi mathvariant="normal">小</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">量</mi><mo>)</mo><mo>∗</mo><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo><mi mathvariant="normal">右</mi><mi mathvariant="normal">边</mi><mi mathvariant="normal">比</mi><mi mathvariant="normal">他</mi><mi mathvariant="normal">大</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">量</mi></mrow><annotation encoding="application/x-tex">ans=\sum_{i=1}^{n}*(a[i]左边比他小的数的数量)*a[i]右边比他大的数的数量</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∗</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mord cjk_fallback">左</span><span class="mord cjk_fallback">边</span><span class="mord cjk_fallback">比</span><span class="mord cjk_fallback">他</span><span class="mord cjk_fallback">小</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">量</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mord cjk_fallback">右</span><span class="mord cjk_fallback">边</span><span class="mord cjk_fallback">比</span><span class="mord cjk_fallback">他</span><span class="mord cjk_fallback">大</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">量</span></span></span></span>。</p>
<p>就可以先离散化再2次树状数组就好了。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
int a[200005],b[200005],ans;
int fuck1[200005],fuck2[200005],n,len;
int Left[200005],Right[200005];//开小数组见祖宗 
inline int lowbit(int x){return x&amp;-x;}
inline int add1(int x){for(int i=x;i&lt;=len;i+=lowbit(i))fuck1[i]++;}
inline int add2(int x){for(int i=x;i&lt;=len;i+=lowbit(i))fuck2[i]++;}
inline int ask1(int x){int sum=0;for(int i=x;i;i-=lowbit(i)){sum+=fuck1[i];} return sum;}
inline int ask2(int x){int sum=0;for(int i=x;i;i-=lowbit(i)){sum+=fuck2[i];} return sum;}
signed main() {
    freopen(&quot;T2.in&quot;,&quot;r&quot;,stdin);
    freopen(&quot;T2.out&quot;,&quot;w&quot;,stdout);
	read(n);
	For(i,1,n)read(a[i]),b[i]=a[i];
	
    sort(b+1,b+n+1);
	len=unique(b+1,b+n+1)-b-1;
	For(i,1,n) a[i]=lower_bound(b+1,b+len+1,a[i])-b;//离散化

	For(i,1,n) add1(a[i]),Left[i]=ask1(a[i]-1);
	for(int i=n;i&gt;=1;--i) add2(a[i]),Right[i]=ask2(len)-ask2(a[i]);
    
	For(i,1,n) ans+=Left[i]*Right[i];
	write(ans);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树状数组求逆序对]]></title>
        <id>https://441135118wz.github.io/accepted/post/shu-zhuang-shu-zu-qiu-ni-xu-dui/</id>
        <link href="https://441135118wz.github.io/accepted/post/shu-zhuang-shu-zu-qiu-ni-xu-dui/">
        </link>
        <updated>2020-07-01T13:18:00.000Z</updated>
        <content type="html"><![CDATA[<p>从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 枚举，考虑当前枚举到的位置 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> ，他对总的逆序对的个数的贡献就是他前面的权值大于他的权值的数的个数，所以我们在i的权值的位置修改树状数组，表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 的权值这个数已经出现过了，那么到了后面就可以直接查询从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 的权值的位置的总和。</p>
<pre><code class="language-cpp">void add(int i,int t){
    while(i&lt;=len){//这里的len是元素种类，具体见上一篇博客
        c[i]+=t;
        i+=lowbit(i);
    }
}
int main(){
    int n;
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++){
        int t;
        cin&gt;&gt;t;
        add(t,1);
        ans+=i-sum(t);
    }
    for(int i=1;i&lt;=n;i++){
        cout&lt;&lt;c[i]&lt;&lt;endl;
    }
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[离散化]]></title>
        <id>https://441135118wz.github.io/accepted/post/chi-san-hua/</id>
        <link href="https://441135118wz.github.io/accepted/post/chi-san-hua/">
        </link>
        <updated>2020-07-01T12:36:26.000Z</updated>
        <content type="html"><![CDATA[<p>离散化：</p>
<pre><code class="language-cpp">For(i,1,n){
	read(a[i].v);
    a[i].id=i;
}
sort(a+1,a+1+n);按v排序
For(i,1,n) b[a[i].id]=i;
</code></pre>
<pre><code class="language-cpp">For(i,1,n)read(a[i]),b[i]=a[i];
 sort(b+1,b+n+1);
len=unique(b+1,b+n+1)-b-1;
For(i,1,n) a[i]=lower_bound(b+1,b+len+1,a[i])-b;
</code></pre>
<p>这是离散化代码。</p>
<p>我来帮助理解一下：</p>
<table>
<thead>
<tr>
<th>v</th>
<th>1005</th>
<th>12</th>
<th>234</th>
<th>5</th>
<th>3421</th>
<th>11111</th>
<th>42</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>
</tbody>
</table>
<p>排序过后：</p>
<table>
<thead>
<tr>
<th>v</th>
<th>5</th>
<th>12</th>
<th>42</th>
<th>234</th>
<th>1005</th>
<th>3421</th>
<th>11111</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>4</td>
<td>2</td>
<td>7</td>
<td>3</td>
<td>1</td>
<td>5</td>
<td>6</td>
</tr>
</tbody>
</table>
<p>最后赋值进b数组</p>
<table>
<thead>
<tr>
<th>b[1]</th>
<th>b[2]</th>
<th>b[3]</th>
<th>b[4]</th>
<th>b[5]</th>
<th>b[6]</th>
<th>b[7]</th>
</tr>
</thead>
<tbody>
<tr>
<td>5</td>
<td>2</td>
<td>4</td>
<td>1</td>
<td>6</td>
<td>7</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>感性理解一下就很简单了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[STL总结]]></title>
        <id>https://441135118wz.github.io/accepted/post/stl-zong-jie/</id>
        <link href="https://441135118wz.github.io/accepted/post/stl-zong-jie/">
        </link>
        <updated>2020-06-30T13:12:40.000Z</updated>
        <content type="html"><![CDATA[<h1 id="迭代器">迭代器</h1>
<p>迭代器是一个变量，相当于容器和操纵容器的算法之间的中介。迭代器可以指向容器中的某个元素，通过迭代器就可以读写它指向的元素。</p>
<h1 id="unique">unique</h1>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>unique</mtext></mrow><annotation encoding="application/x-tex">\text {unique}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8623000000000001em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">unique</span></span></span></span></span> 是STL比较实用的一个函数。用于“去除”容器内相邻的重复的元素（只保留一个）。这里说的去除并不是真正将容器内的重复元素删去，只是把重复的元素移到容器最后，但是依然在容器内。 对于数组而言返回去重后最后一个元素的指针，而其他容器则是返回去重后最后一个元素的迭代器。</p>
<h3 id="用法举例">用法举例</h3>
<p>因为是去除相邻的重复元素，因此通常使用前容器应该要是有序的。</p>
<p>数组:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
int main()
{
  int a[6] = {1,1,4,6,6,7};
  int *p = unique(a,a+6);
  cout &lt;&lt; &amp;a[4] &lt;&lt; endl;
  cout &lt;&lt; p &lt;&lt; endl;
  cout &lt;&lt; p - a &lt;&lt;endl;
  for(int i = 0;i &lt; p-a;i++)
      cout &lt;&lt; a[i] &lt;&lt; endl;
  return 0;
}
</code></pre>
<h1 id="vector">vector</h1>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>vector</mtext></mrow><annotation encoding="application/x-tex">\text {vector}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord text"><span class="mord">vector</span></span></span></span></span>可以看成是什么都可以放进去的线性表。</p>
<p>用法：</p>
<pre><code class="language-cpp">vector&lt;int&gt;v;//vector元素为 int 型  
vector&lt;int&gt;::iterator it;//定义一个迭代器

v.push_back()    //在数组的最后添加一个数据
v.pop_back()     //去掉数组的最后一个数据 v.front() 　　　　//返回第一个元素(栈顶元素)
v.begin()        //得到数组头的指针，用迭代器接受
v.end()          //得到数组的最后一个单元+1的指针，用迭代器接受
v.clear()        //移除容器中所有数据
v.empty()        //判断容器是否为空
v.erase(pos)     //删除pos位置的数据
v.erase(beg,end) //删除[beg,end)区间的数据
v.size()         //回容器中实际数据的个数v.insert(pos,data) //在pos处插入数据
</code></pre>
<h1 id="deque">deque</h1>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>deque</mtext></mrow><annotation encoding="application/x-tex">\text {deque}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">deque</span></span></span></span></span> 是双端队列STL，是一种两端都可以进出元素的结构。</p>
<p>用法：</p>
<pre><code class="language-cpp">deque&lt;int&gt; d;
d.push_front(x);    //双端队列头部增加一个元素X
d.push_back(x);     //双端队列尾部增加一个元素X
d.pop_front();      //双端队列头部弹出一个元素X
d.pop_back();       //双端队列尾部弹出一个元素X
d.clear();          //清空双端队列中元素
d.empty();          //队列中是否有元素
d.size();           //队列中元素个数
d.front();          //队列中头部元素
d.back();           //队列中尾部元素
d.begin();          //指向头部元素
d.end();            //指向尾部元素

</code></pre>
<h1 id="stack">stack</h1>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>stack</mtext></mrow><annotation encoding="application/x-tex">\text {stack}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord">stack</span></span></span></span></span>是栈STL，是一种先进后出的结构。</p>
<p>用法：</p>
<pre><code class="language-cpp">stack&lt;int&gt; s;
s.empty();	//栈中是否有元素
s.size();	//栈中元素个数
s.pop();	//弹出栈顶元素
s.top();	//反回栈顶元素
s.push(x);  //栈中压入x元素
</code></pre>
<h1 id="queue">queue</h1>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>queue</mtext></mrow><annotation encoding="application/x-tex">\text {queue}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">queue</span></span></span></span></span> 是队列STL，是一种先进先出的结构。</p>
<p>用法：</p>
<pre><code class="language-cpp">q.empty()// 如果队列为空返回true，否则返回false
q.size() // 返回队列中元素的个数
q.pop()  //删除队列首元素
q.front()  // 返回队首元素的值 
q.push(X) //在队尾压入新元素X
q.back() //返回队列尾元素的值  
</code></pre>
<h1 id="priority_queue">priority_queue</h1>
<p><span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;_&#039; at position 16: \text {priority_̲queue}'>\text {priority_queue}</span>是优先队列STL，优先队列是队列的一种，不过它可以按照自定义的一种方式（数据的优先级）来对队列中的数据进行动态的排序，每次的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>push</mtext></mrow><annotation encoding="application/x-tex">\text {push}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">push</span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>pop</mtext></mrow><annotation encoding="application/x-tex">\text {pop}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">pop</span></span></span></span></span> 操作，队列都会动态的调整，以达到我们预期的方式来存储。</p>
<p>例如，将元素 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>5 3 2 4 6</mtext></mrow><annotation encoding="application/x-tex">\text {5 3 2 4 6}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord text"><span class="mord">5 3 2 4 6</span></span></span></span></span> 依次 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>push</mtext></mrow><annotation encoding="application/x-tex">\text {push}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">push</span></span></span></span></span> 到优先队列中，规定顺序为从大到小并输出，输出顺序为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>6 5 4 3 2</mtext></mrow><annotation encoding="application/x-tex">\text {6 5 4 3 2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord text"><span class="mord">6 5 4 3 2</span></span></span></span></span></p>
<p>定义</p>
<pre><code class="language-cpp">priority_queue&lt;int&gt; p;//最大值优先，是大顶堆一种简写方式
priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;q1;//最小值优先，小顶堆
priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt;q2;//最大值优先，大顶堆

//其中第一个参数是数据类型，第二个参数为容器类型。第三个参数为比较函数。
</code></pre>
<p>在使用时，我们会有很多时间用到根据结构体的某一个元素进行排序，下面给出定义结构体的优先级比较方式</p>
<pre><code class="language-cpp">struct node
{
    string name;
    int price;
    friend bool operator&lt; (node a, node b)
    {
        return a.price &lt; b.price; // 相当于less,这是大顶堆，反之则是小顶堆，最大值优先
    }
} stu; //定义结构体变量

//这样直接可以：
priority_queue&lt;node &gt; q;
</code></pre>
<p>可以将比较运算符外置，方法如下</p>
<pre><code class="language-cpp">struct node
{
    string name;
    int price;
} stu; //定义结构体变量

struct cmp
{
    bool operator () (node a, node b) // 重载括号
    {
        return node.price &lt; node.price; // 相当于less，大顶堆
    }
};
</code></pre>
<p>3.常用操作：</p>
<pre><code class="language-cpp">q.push(x) //将x加入队列中，即入队操作

q.pop() //出队操作(删除队列首元素)，只是出队，没有返回值

q.top() //返回第一个元素(队首元素)优先队列的队首用top，而普通队列的队首用front

q.size() //返回栈队列中的元素个数

q.empty() //当队列为空时，返回 true
</code></pre>
<p>这里放下 <a href="https://www.luogu.com.cn/problem/P1090#submit">P1090 合并果子</a> 的代码，方便理解使用 <span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;_&#039; at position 16: \text {priority_̲queue}'>\text {priority_queue}</span>：</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q;
int main(){
    int a,b,x,y,ans=0;
    read(a);
	For(i,0,a-1) read(b),q.push(b);
	For(i,1,a-1){
		x=q.top();q.pop();
         y=q.top();q.pop();
		q.push(x+y);ans+=x+y;
	}
	write(ans);
}
</code></pre>
<h1 id="set">set</h1>
<h2 id="介绍">介绍</h2>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>set</mtext></mrow><annotation encoding="application/x-tex">\text {set}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord text"><span class="mord">set</span></span></span></span></span> 是集合<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>STL</mtext></mrow><annotation encoding="application/x-tex">\text {STL}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">STL</span></span></span></span></span> ，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>set</mtext></mrow><annotation encoding="application/x-tex">\text {set}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord text"><span class="mord">set</span></span></span></span></span> 是一个内部自动有序且不含重复元素的容器。</p>
<p><strong>set最主要的作用是自动去重并按升序排序</strong></p>
<h2 id="用法">用法：</h2>
<h3 id="1set的定义">1.set的定义</h3>
<pre><code class="language-cpp">set&lt;typename&gt; name；
//这里的typename可以是任何基本类型
//举例：
set&lt;int&gt; name;
set&lt;double&gt; name;
set&lt;char&gt; name;
set&lt;node&gt; name; //node是结构体的类型
</code></pre>
<h3 id="2-set-容器内元素的访问">2. set 容器内元素的访问</h3>
<pre><code>//（重点）set 只能通过迭代器(iterator)访问
set&lt;typename&gt;::iterator it;
</code></pre>
<p>举例：</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int main() {
    set&lt;int&gt; st;
    st.insert(3);   //insert(x)将x插入set中
    st.insert(5);
    st.insert(2);
    st.insert(3);
    for(set&lt;int&gt;::iterator it = st.begin(); it != st.end(); it++) {
        printf(&quot;%d&quot;, *it);
    }
}
</code></pre>
<h3 id="3set常用函数">3.set常用函数</h3>
<ol>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>insert(x)</mtext></mrow><annotation encoding="application/x-tex">\text {insert(x)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">insert(x)</span></span></span></span></span></li>
</ol>
<pre><code class="language-cpp">insert(x);         //insert(x)可将 x 插入 set 容器中，并自动递增排序和去重，时间复杂度O(logN)
</code></pre>
<ol start="2">
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>find(value)</mtext></mrow><annotation encoding="application/x-tex">\text {find(value)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">find(value)</span></span></span></span></span></li>
</ol>
<pre><code class="language-cpp">find(value);       //find(value)返回 set 中对应值为 value 的迭代器，时间复杂度为O(logN)
//用法：
set&lt;int&gt;::iterator it = st.find(2); //在set中查找2,返回其迭代器
printf(&quot;%d\n&quot;, *it);
//以上两句也可以直接写成printf(&quot;%d\n&quot;, *(st.find(2)));
</code></pre>
<ol start="3">
<li>$ \text {erase()}$</li>
</ol>
<pre><code class="language-cpp">erase();
//erase()有两种用法：删除单个元素，删除一个区间内的所有元素
// 1. 删除单个元素
//删除单个元素的方法有两种
//st.erase(it), it为所需要删除元素的迭代器。时间复杂度为O(1)
st.erase(st.find(x));//利用find()函数找到x,然后用erase删除它

//st.erase(value), value为所需要删除元素的值。时间复杂度为O(logN)
st.erase(x);  //删除set中值为x的元素


// 2.删除一个区间内的所有元素
//st.erase(first, last)可以删除一个区间内的所有元素
//first为所需要删除区间的起始迭代器，last则为所需要删除区间的末尾迭代器的下一地址
//即删除[first, last)， 时间复杂度为O(last - first)
set&lt;int&gt;::iterator it1 = st.find(x);
set&lt;int&gt;::iterator it2 = st.find(y);
st.erase(it1, it2); //删除元素x至y之间的元素(包括x和y)
</code></pre>
<ol start="4">
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>size()</mtext></mrow><annotation encoding="application/x-tex">\text {size()}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">size()</span></span></span></span></span></li>
</ol>
<pre><code class="language-cpp">int x=size();//size()用来获得set内元素的个数，时间复杂度为O(1)
</code></pre>
<ol start="5">
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>clear()</mtext></mrow><annotation encoding="application/x-tex">\text {clear()}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">clear()</span></span></span></span></span></li>
</ol>
<pre><code class="language-cpp">set&lt;int&gt; s;
s.clear(); //清空set
</code></pre>
<h1 id="multiset">multiset</h1>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>set</mtext></mrow><annotation encoding="application/x-tex">\text {set}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord text"><span class="mord">set</span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>multiset</mtext></mrow><annotation encoding="application/x-tex">\text {multiset}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord">multiset</span></span></span></span></span> 会根据特定的排序原则将元素排序。两者不同之处在于， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>multiset</mtext></mrow><annotation encoding="application/x-tex">\text {multiset}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord">multiset</span></span></span></span></span> 允许元素重复，而 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>set</mtext></mrow><annotation encoding="application/x-tex">\text {set}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord text"><span class="mord">set</span></span></span></span></span> 不允许重复，其他操作和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>set</mtext></mrow><annotation encoding="application/x-tex">\text {set}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord text"><span class="mord">set</span></span></span></span></span> 都差不多的。</p>
<h1 id="map">map</h1>
<p>说白了就是一个动态的桶。</p>
<p>函数：</p>
<pre><code class="language-cpp">//应该只有这个要用到。。
map&lt;int,int&gt; mp;
mp.clear();//map初始化
</code></pre>
<h1 id="unordered_map">unordered_map</h1>
<p>使用方法和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>map</mtext></mrow><annotation encoding="application/x-tex">\text {map}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">map</span></span></span></span></span><strong>完全</strong>一样！</p>
<p>但是由于底层原理不同，它的查询是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>O(1)</mtext></mrow><annotation encoding="application/x-tex">\text {O(1)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">O(1)</span></span></span></span></span>的，而<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>map</mtext></mrow><annotation encoding="application/x-tex">\text {map}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">map</span></span></span></span></span>的查询却是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>O(log n)</mtext></mrow><annotation encoding="application/x-tex">\text {O(log n)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">O(log n)</span></span></span></span></span>的。</p>
<p>传闻这玩意要C++11才能用 ——假的！</p>
<p>一切都在标准C++范围内。</p>
<h1 id="bitset">bitset</h1>
<p>可以看作一个支持二进制数，每  位占用  个字节，并支持基本的位运算。</p>
<p>类型可以用  和整数初始化（整数转化成对应的二进制）。</p>
<p>举例：</p>
<pre><code>bitset&lt;23&gt;bit (string(&quot;11101001&quot;));
cout&lt;&lt;bit&lt;&lt;endl;
bit=233;
cout&lt;&lt;bit&lt;&lt;endl;
</code></pre>
<p>输出：</p>
<pre><code>00000000000000011101001
00000000000000011101001
</code></pre>
<p>这应该是用的最多的东西了，别的函数还有很多，这里就省略了（觉得没什么用。</p>
<h1 id="binary_search">binary_search</h1>
<p>函数模板：</p>
<pre><code class="language-cpp">binary_search(arr[], arr[]+size, indx);
</code></pre>
<p>参数说明：<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>arr[]</mtext></mrow><annotation encoding="application/x-tex">\text {arr[]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">arr[]</span></span></span></span></span> ：数组首地址<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>size</mtext></mrow><annotation encoding="application/x-tex">\text {size}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66786em;vertical-align:0em;"></span><span class="mord text"><span class="mord">size</span></span></span></span></span>：数组元素个数<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>indx</mtext></mrow><annotation encoding="application/x-tex">\text {indx}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord">indx</span></span></span></span></span>：需要查找的值<br>
函数功能： 在数组中以二分法检索的方式查找，若在数组(要求数组元素非递减)中查找到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>indx</mtext></mrow><annotation encoding="application/x-tex">\text {indx}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord">indx</span></span></span></span></span> 元素则真，若查找不到则返回值为假。</p>
<h1 id="lower_bound">lower_bound</h1>
<p><span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;_&#039; at position 13: \text {lower_̲bound(begin, en…'>\text {lower_bound(begin, end, num)}</span> ：从数组的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>begin</mtext></mrow><annotation encoding="application/x-tex">\text {begin}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">begin</span></span></span></span></span> 位置到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>end - 1</mtext></mrow><annotation encoding="application/x-tex">\text {end - 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord">end - 1</span></span></span></span></span>位置二分查找第一个大于或等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>num</mtext></mrow><annotation encoding="application/x-tex">\text {num}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord text"><span class="mord">num</span></span></span></span></span> 的数字，找到返回该数字的地址，不存在则返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>end</mtext></mrow><annotation encoding="application/x-tex">\text {end}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord">end</span></span></span></span></span> 。通过返回的地址减去起始地址<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>begin</mtext></mrow><annotation encoding="application/x-tex">\text {begin}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">begin</span></span></span></span></span> ，得到找到数字在数组中的下标。</p>
<pre><code class="language-cpp">int num[n+1];
pos=lower_bound(num+1,num+n+1,y)-num;    //返回数组num[1]到num[n]的元素中第一个大于或等于被查数的值的下标
</code></pre>
<h1 id="upper_bound">upper_bound</h1>
<p><span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;_&#039; at position 13: \text {upper_̲bound( begin,en…'>\text {upper_bound( begin,end,num)}</span> ：从数组的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>begin</mtext></mrow><annotation encoding="application/x-tex">\text {begin}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">begin</span></span></span></span></span> 位置到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>end - 1</mtext></mrow><annotation encoding="application/x-tex">\text {end - 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord">end - 1</span></span></span></span></span> 位置二分查找第一个小于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>num</mtext></mrow><annotation encoding="application/x-tex">\text {num}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord text"><span class="mord">num</span></span></span></span></span> 的数字，找到返回该数字的地址，不存在则返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>end</mtext></mrow><annotation encoding="application/x-tex">\text {end}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord">end</span></span></span></span></span> 。通过返回的地址减去起始地址 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>begin</mtext></mrow><annotation encoding="application/x-tex">\text {begin}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">begin</span></span></span></span></span> ，得到找到数字在数组中的下标。</p>
<pre><code class="language-cpp">int num[n+1];
pos=upper_bound(num+1,num+n+1,y)-num;    //返回数组num[1]到num[n]的元素中第一个大于被查数的值的下标
</code></pre>
<h1 id="reverse">reverse</h1>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>reverse()</mtext></mrow><annotation encoding="application/x-tex">\text {reverse()}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">reverse()</span></span></span></span></span> 函数可以对字符串进行反转操作。</p>
<p>容器类型的要用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>begin()</mtext></mrow><annotation encoding="application/x-tex">\text {begin()}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">begin()</span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>end()</mtext></mrow><annotation encoding="application/x-tex">\text {end()}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">end()</span></span></span></span></span> 来指定反转的区域，数组类型的直接用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>int</mtext></mrow><annotation encoding="application/x-tex">\text {int}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66786em;vertical-align:0em;"></span><span class="mord text"><span class="mord">int</span></span></span></span></span> 类型即可。</p>
<h3 id="使用方法">使用方法</h3>
<ol>
<li>交换 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>vector</mtext></mrow><annotation encoding="application/x-tex">\text {vector}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord text"><span class="mord">vector</span></span></span></span></span> 容器中元素顺序</li>
</ol>
<pre><code class="language-cpp">vector&lt;int&gt; v = {5,4,3,2,1};
reverse(v.begin(),v.end());//v的值为1,2,3,4,5
</code></pre>
<ol start="2">
<li>交换 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>string</mtext></mrow><annotation encoding="application/x-tex">\text {string}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8623000000000001em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">string</span></span></span></span></span> 字符串中元素的顺序</li>
</ol>
<pre><code class="language-cpp">string str=&quot;hello&quot;;
reverse(str.begin(),str.end());//str结果为olleh
</code></pre>
<ol start="3">
<li>交换字符数组 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>char[]</mtext></mrow><annotation encoding="application/x-tex">\text {char[]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">char[]</span></span></span></span></span> 中元素的顺序</li>
</ol>
<pre><code class="language-cpp">char a[101] = “hello world”;
reverse(a,a+strlen(a));
</code></pre>
<ol start="4">
<li>翻转一个数组</li>
</ol>
<pre><code class="language-cpp">int a[5+1]={0,1,2,3,4,5};
reverse(a+1,a+n+1);
</code></pre>
<h1 id="random_shuffle">random_shuffle</h1>
<p><span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;_&#039; at position 14: \text {random_̲shuffle()}'>\text {random_shuffle()}</span> 函数可以随机打乱容器内元素，用法和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>reverse()</mtext></mrow><annotation encoding="application/x-tex">\text {reverse()}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">reverse()</span></span></span></span></span> 相同。</p>
<pre><code class="language-cpp">int a[5+1]={0,1,2,3,4,5};
random_shuffle(a+1,a+n+1);
</code></pre>
<h1 id="next_permutation">next_permutation</h1>
<p><span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;_&#039; at position 12: \text {next_̲permutation}'>\text {next_permutation}</span> 是全排列函数。</p>
<p>用法比较少，下面是用这个函数实现全排列的代码：</p>
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;algorithm&gt;
using namespace std;
int main(){
    int n;
    while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n){
        int a[1000];
        for(int i=0;i&lt;n;i++){
            scanf(&quot;%d&quot;,&amp;a[i]);
        }
        sort(a,a+n);
        do{
            for(int i=0;i&lt;n;i++)
                printf(&quot;%d &quot;,a[i]);
            printf(&quot;\n&quot;);
        }while(next_permutation(a,a+n));
    }
    return 0;
}
</code></pre>
<h1 id="注意事项重要">注意事项（重要）：</h1>
<ol>
<li>除开 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>vector</mtext></mrow><annotation encoding="application/x-tex">\text {vector}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord text"><span class="mord">vector</span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>string</mtext></mrow><annotation encoding="application/x-tex">\text {string}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8623000000000001em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">string</span></span></span></span></span> 之外的STL容器都不支持 $*( \text {it} +\text  i) $ 的访问方式（这里 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>it</mtext></mrow><annotation encoding="application/x-tex">\text {it}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66786em;vertical-align:0em;"></span><span class="mord text"><span class="mord">it</span></span></span></span></span> 是迭代器）</li>
<li>大多数STL都需要特定的头文件，但是万能头是全部都包含的，为了方便，也为了安全，请使用万能头。</li>
</ol>
<h1 id="后记">后记</h1>
<p>对于初学者来说，STL尽量不要使用，要理解STL实现的原理，STL只是用于简化代码的，而不是用来当算法学习的。</p>
<p>STL就像是一个个封装好的工具，可以任你挑选使用，但是你需要先知道，哪个工具适合于你，也需要学会使用工具，这篇文章则是更偏向于讲后者。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[左偏树]]></title>
        <id>https://441135118wz.github.io/accepted/post/zuo-pian-shu/</id>
        <link href="https://441135118wz.github.io/accepted/post/zuo-pian-shu/">
        </link>
        <updated>2020-06-29T12:00:43.000Z</updated>
        <content type="html"><![CDATA[<p>左偏树</p>
<p>核心：merge函数</p>
<p>思想：</p>
<p>左偏树的合并是一个递归过程，对于以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 为根的树：</p>
<p>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 二者之一为空树，则返回另一棵。</p>
<p>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 均不为空，则比较 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 的权值大小。</p>
<p>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的权值较大，那么就把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 右儿子和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 合并的结果作为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 新的右儿子，返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> ；</p>
<p>否则就把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 交换，继续上面的操作。</p>
<p>合并以后由于我们还要维护左偏性质，即：如果合并后右儿子的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">dis</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span></span></span></span> 大于左儿子的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">dis</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span></span></span></span> ，则交换左右儿子。</p>
<p>这便是通过左偏树来实现可并堆的模拟过程。</p>
<p>代码：</p>
<pre><code class="language-cpp">int merge(int x,int y)
{
    if(!x) return y;
    if(!y) return x;
    if(v[x]&lt;v[y]) swap(x,y);
    rson[x]=merge(rson[x],y);
    if(dis[r[x]]&gt;dis[l[x]]) swap(lson[x],rson[x]);
    dis[x]=dis[rson[x]]+1;
    return x;
}
</code></pre>
<p>洛谷左偏树模板代码：</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 100010;
int n, m, op, x, y;
int lson[maxn], rson[maxn], dist[maxn], fa[maxn];
bool tf[maxn];
struct node{
	int id, v;
	bool operator&lt;(node x) const { 
		return v == x.v ? id &lt; x.id : v &lt; x.v; 
	}
} v[maxn];
int find(int x){ 
	return fa[x] == x ? x : fa[x] = find(fa[x]); 
}
int merge(int x, int y){
	if (!x || !y)
		return x + y;
	if (v[y] &lt; v[x])
		swap(x, y);
	rson[x] = merge(rson[x], y);
	if (dist[lson[x]] &lt; dist[rson[x]])
		swap(lson[x], rson[x]);
	dist[x] = dist[rson[x]] + 1;
	return x;
}
int main()
{
	dist[0] = -1;
	read(n);
	read(m);
	For(i,1,n)
		read(v[i].v), fa[i] = i, v[i].id = i;
	while (m--)
	{
		read(op);
		read(x);
		if (op == 1)
		{
			read(y);
			if (tf[x] || tf[y])
				continue;
			x = find(x);
			y = find(y);
			if (x != y)
				fa[x] = fa[y] = merge(x, y);
		}
		if (op == 2)
		{
			if (tf[x])
			{
				printf(&quot;-1\n&quot;);
				continue;
			}
			x = find(x);
			printf(&quot;%d\n&quot;, v[x].v);
			tf[x] = true;
			fa[lson[x]] = fa[rson[x]] = fa[x] = merge(lson[x], rson[x]);
			lson[x] = rson[x] = dist[x] = 0;
		}
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[struct重载运算符用法]]></title>
        <id>https://441135118wz.github.io/accepted/post/struct-chong-zai-yun-suan-fu-yong-fa/</id>
        <link href="https://441135118wz.github.io/accepted/post/struct-chong-zai-yun-suan-fu-yong-fa/">
        </link>
        <updated>2020-06-29T06:43:30.000Z</updated>
        <content type="html"><![CDATA[<p>operator是c++的重载运算符，字面意思，自己理解。</p>
<p>一般回放在struct结构体当中，可以直接把结构体中的变量用运算符搞，挺方便的。</p>
<p>重载运算符的格式如下：</p>
<p>bool operator 运算符 (const 结构体名称 b) const</p>
<p>{<br>
return(什么时候这个运算符对结构体成立);//注意对此运算符使用this-&gt;元素名；</p>
<p>}</p>
<p>举例</p>
<pre><code class="language-cpp">struct point
{
	    int elem;
	    bool operator&lt;(point b)const
    	{
	    	    return elem&gt;b.elem;
	    }
};

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[杂记]]></title>
        <id>https://441135118wz.github.io/accepted/post/za-ji/</id>
        <link href="https://441135118wz.github.io/accepted/post/za-ji/">
        </link>
        <updated>2020-06-28T12:17:58.000Z</updated>
        <content type="html"><![CDATA[<p>1、“<strong>对所有的</strong>”、“<strong>对任意一个</strong>”等词在逻辑中被称为全称量词，记作 “<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∀</mi></mrow><annotation encoding="application/x-tex">\forall</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">∀</span></span></span></span>”，含有全称量词的命题叫做全称命题。<br>
对<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>中任意的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>，有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">p(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>成立，记作 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∀</mi><mi>x</mi><mo>∋</mo><mi>M</mi><mo separator="true">,</mo><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\forall x \ni M,p(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord">∀</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∋</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>。<br>
读作：每一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>属于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>，使<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">p(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>成立。<br>
2、“<strong>存在一个</strong>”、“<strong>至少有一个</strong>”等词在逻辑中被称为存在量词，记作 “<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∃</mi></mrow><annotation encoding="application/x-tex">\exists</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">∃</span></span></span></span>”，含有存在量词的命题叫做特称命题。<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>中至少存在一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>，使<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">p(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>成立，记作 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∃</mi><mi>x</mi><mo>∋</mo><mi>M</mi><mo separator="true">,</mo><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\exists x\ni M,p(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord">∃</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∋</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>。<br>
读作：存在一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>属于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>，使<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">p(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>成立。</p>
<p>什么是卷积？就是求一个多项式 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>∗</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">p(x)=f(x)*g(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 满足 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>[</mo><mi>k</mi><mo>]</mo><mo>=</mo><msub><mo>∑</mo><mrow><mi>i</mi><mo>+</mo><mi>j</mi><mo>=</mo><mi>k</mi></mrow></msub><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>×</mo><mi>g</mi><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">p[k]=\sum\limits_{i+j=k}f[i]\times g[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.888226em;vertical-align:-1.138221em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7500050000000001em;"><span style="top:-2.097887em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-3.0000050000000003em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.138221em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span></p>
<p>欧拉定理</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mrow><mi>φ</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow></msup><mo>≡</mo><mn>1</mn><mo>(</mo><mtext> </mtext><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mi>n</mi><mo>)</mo><mo separator="true">,</mo><mi>gcd</mi><mo>⁡</mo><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>n</mi><mo>)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a^{\varphi(n)} \equiv 1 (\bmod n),\gcd(a,n)=1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.938em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">φ</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mopen">(</span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span style="margin-right:0.01389em;">g</span>cd</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p>
<p>推广</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>A</mi><mi>B</mi></msup><mtext> </mtext><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mi>C</mi><mo>=</mo><msup><mi>A</mi><mrow><mi>B</mi><mi mathvariant="normal">%</mi><mi>φ</mi><mo>(</mo><mi>C</mi><mo>)</mo><mo>+</mo><mi>φ</mi><mo>(</mo><mi>C</mi><mo>)</mo></mrow></msup><mtext> </mtext><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mi>C</mi><mo separator="true">,</mo><mi>B</mi><mo>≥</mo><mi>φ</mi><mo>(</mo><mi>C</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">A^B\bmod C=A^{B\%\varphi(C)+\varphi(C)} \bmod C , B\ge \varphi(C)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8913309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.938em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span><span class="mord mtight">%</span><span class="mord mathdefault mtight">φ</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span><span class="mclose mtight">)</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">φ</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mclose">)</span></span></span></span></span></p>
<h2 id="广义容斥">广义容斥</h2>
<h4 id="1若">1.若</h4>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></munderover><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><mi>n</mi><mi>m</mi></mfrac><mo fence="true">)</mo></mrow><mi>g</mi><mo>(</mo><mi>i</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(n)=\sum^{n}_{i=0}\binom {n}{m}g(i)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1075599999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">m</span></span></span><span style="top:-3.6769999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span></span></p>
<p>那么</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></munderover><mo>(</mo><mo>−</mo><mn>1</mn><msup><mo>)</mo><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><mi>n</mi><mi>i</mi></mfrac><mo fence="true">)</mo></mrow><mi>f</mi><mo>(</mo><mi>i</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">g(n)=\sum^{n}_{i=0}(-1)^{n-1}\binom {n}{i}f(i)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1075599999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">i</span></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span></span></p>
<h3 id="2若">2.若</h3>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>k</mi><mo>)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mi>k</mi></mrow><mi>n</mi></munderover><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><mi>i</mi><mi>k</mi></mfrac><mo fence="true">)</mo></mrow><mi>g</mi><mo>(</mo><mi>i</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(k)=\sum^{n}_{i=k}\binom {i}{k}g(i)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.9535100000000005em;vertical-align:-1.302113em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.302113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.33652em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span></span></p>
<p>那么</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>(</mo><mi>k</mi><mo>)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mi>k</mi></mrow><mi>n</mi></munderover><mo>(</mo><mo>−</mo><mn>1</mn><msup><mo>)</mo><mrow><mi>i</mi><mo>−</mo><mi>k</mi></mrow></msup><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><mi>i</mi><mi>k</mi></mfrac><mo fence="true">)</mo></mrow><mi>f</mi><mo>(</mo><mi>i</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">g(k)=\sum^{n}_{i=k}(-1)^{i-k}\binom {i}{k}f(i)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.9535100000000005em;vertical-align:-1.302113em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.302113em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.33652em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span></span></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[lca复习小结（代码实现）]]></title>
        <id>https://441135118wz.github.io/accepted/post/628/</id>
        <link href="https://441135118wz.github.io/accepted/post/628/">
        </link>
        <updated>2020-06-28T07:18:32.000Z</updated>
        <content type="html"><![CDATA[<h1 id="lca">LCA</h1>
<h3 id="dfs"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">dfs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">s</span></span></span></span>:</h3>
<ol>
<li>
<p>现在的节点的上面一个节点是它的父亲，节点的深度是他父亲的深度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">+</span><span class="mord">1</span></span></span></span></p>
</li>
<li>
<p>预处理，这个节点的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>个祖先。</p>
<pre><code class="language-cpp">for (int i = 1; i &lt;= lg[depth[now]]; ++i)
        fa[now][i] = fa[fa[now][i-1]][i-1];
</code></pre>
</li>
<li>
<p>递归遍历图。</p>
</li>
</ol>
<h3 id="lcaxy"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>C</mi><mi>A</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">LCA(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>:</h3>
<ol>
<li>
<p>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的深度比 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 浅，就交换，确保 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 比 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 深。</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 一直跳到和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 深度相同的时候。</p>
</li>
</ol>
<pre><code class="language-c++">while(depth[x] &gt; depth[y])
        x=fa[x][lg[depth[x]-depth[y]]-1];
</code></pre>
<ol start="3">
<li>
<p>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 是同一个节点，就直接 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>e</mi><mi>t</mi><mi>u</mi><mi>r</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">return</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">n</span></span></span></span> 。</p>
</li>
<li>
<p>能跳就跳。</p>
<pre><code class="language-c++">for(int k = lg[depth[x]] - 1; k &gt;= 0; --k)
		if(fa[x][k] != fa[y][k])
			x = fa[x][k], y = fa[y][k];
</code></pre>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>e</mi><mi>t</mi><mi>u</mi><mi>r</mi><mi>n</mi><mtext> </mtext><mi>f</mi><mi>a</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>[</mo><mn>0</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">return\ fa[x][0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">n</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span></p>
</li>
</ol>
]]></content>
    </entry>
</feed>